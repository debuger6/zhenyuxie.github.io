<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="description">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      Pebble 源码剖析-写入流程 | Debuger
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/css/plugins/gitment.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
  
    
<script src="/js/gitment.js"></script>

  
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


  
  
    
<script src="/js/local-search.js"></script>


<meta name="generator" content="Hexo 6.3.0"></head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>
  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>Debuger</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/project/" class="item-link">Projects</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
      
        <li class="menu-item menu-item-search right-list">
    <a role="button" class="popup-trigger">
        <i class="fa fa-search fa-fw"></i>
    </a>
</li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/project/" class="menu-link">Projects</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
    
      <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
            <span class="search-icon">
                <i class="fa fa-search"></i>
            </span>
            <div class="search-input-container">
                <input autocomplete="off" autocapitalize="off"
                    placeholder="Please enter your keyword(s) to search." spellcheck="false"
                    type="search" class="search-input">
            </div>
            <span class="popup-btn-close">
                <i class="fa fa-times-circle"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>
    
  </div>
</header>

    <div id="article-banner">
  <h2>Pebble 源码剖析-写入流程</h2>
  <p class="post-date">2022-01-24</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><p>本章会结合 Pebble 源码来剖析整个写入流程，并会深入分析整个写入路径上涉及的一些技术细节。这里说明，文章只会贴一些关键代码和代码行数较少的函数或者方法，尽量避免太多代码内容影响阅读感受。</p>
<h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><p>为了便于大家理解，首先会科普一些基础概念，有基础的同学可以直接跳过。为了更直观的理解，我们先将<a href="https://zhenyuxie.github.io/2022/01/20/pebble-intr/">上一章</a>的图搬过来。</p>
<p><img src="/images/pebble/LSM.png" alt="LSM"></p>
<h4 id="WAL"><a href="#WAL" class="headerlink" title="WAL"></a>WAL</h4><p>Wal（Write ahead of log）即预写日志，其是一种日志结构，每条日志包含了数据的原始内容并以追加写的方式写入磁盘文件，在数据写入内存前需将原始数据写入到 Wal。Wal 的写入模式可以分为 Sync（同步）和 Async（异步），如果为同步写则前台需阻塞等待日志落盘，异步写只需将日志记录写到内存缓存后便可返回。因此，同步模式可靠性更高但性能偏低，异步模式性能很好但有丢数据的风险，需根据具体场景合理选择使用哪种模式。Wal 的具体格式会在下面源码分析阶段详细介绍。</p>
<h4 id="Memtable"><a href="#Memtable" class="headerlink" title="Memtable"></a>Memtable</h4><p>Memtable 是数据（KV Pairs）在内存中的载体，业务数据写入 Pebble 后，首先写 Wal，然后会写入到 Memtable，数据在 Memtable 中会按序存储。Memtable 有两种形式，一种是 Mutable Memtable（可变），另外一种是 Immutable Memtable（不可变），顾名思义，前者可以同时支持读写，而后者只能读不能写。Memtable（默认指是 Mutable）一般会有大小限制，写满后会转变为 Immutable，Immutable 会由专门后台线程按照某种策略刷到磁盘，同时释放内存并清理对应的 Wal。</p>
<h4 id="SSTable"><a href="#SSTable" class="headerlink" title="SSTable"></a>SSTable</h4><p>SSTable 即 Sorted String Table 简称为 SST，由内存中的 Memtable 刷盘而成，是一种有序的、不修改的磁盘文件格式，其中 Key 和 Value 都可以是任意的 byte 序列。和 RocksDB&#x2F;LevelDB 一样，SST 在 Pebble 中也是按层组织，数据首先刷入到第 0 层，在到达一定数量后后被后台线程 Merge 并 Compact 到下层。每层的数据量按倍数增长，越往下层数据量越大，同时数据也越老。</p>
<p>由于本章只分析写入流程，因此我们先科普上述三个比较重要的概念，其他知识后面涉及再详细展开。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>有了上面的预备知识，本节可以开始对源码进行剖析了。首先贴上官方的 Demo 程序：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/cockroachdb/pebble&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	db, err := pebble.Open(<span class="string">&quot;demo&quot;</span>, &amp;pebble.Options&#123;&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	key := []<span class="type">byte</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err := db.Set(key, []<span class="type">byte</span>(<span class="string">&quot;world&quot;</span>), pebble.Sync); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	value, closer, err := db.Get(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s %s\n&quot;</span>, key, value)</span><br><span class="line">	<span class="keyword">if</span> err := closer.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := db.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 Pebble 的使用还是比较简单，首先根据配置项打开一个 DB，然后便可以向该 DB 进行读写操作了。这里顺便介绍配置项 Options 的一些常用且重要的选项，便于后续理解。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BytesPerSync <span class="comment">// 控制 sstable 按照该值平滑刷盘，防止系统一次性刷大量脏页导致写入延时抖动，默认值是 512KB</span></span><br><span class="line">WALBytesPerSync <span class="comment">// 控制 wal 按照该值平滑刷盘，不过 Pebble 认为该值一般情况下没必要设置，因为大部分场景 wal 是 sync 写入的，默认值是 0</span></span><br><span class="line">DisableWAL <span class="comment">// 是否关闭 Wal，该参数为 true 时，不写 Wal，数据可靠性最低，默认为 false</span></span><br><span class="line">L0CompactionThreshold <span class="comment">// level 0 读放大 compaction 阈值，到达阈值后将触发 L0 compaction，默认值是 4</span></span><br><span class="line">L0StopWritesThreshold <span class="comment">// level 0 的读放大停写阈值，达到阈值后将阻塞写，默认值是 12</span></span><br><span class="line">LBaseMaxBytes <span class="comment">// level 0 compaction 至的 level 最大容量，其他层的最大容量会根据该值动态计算，默认是 64 MB</span></span><br><span class="line">MemTableSize  <span class="comment">// memtable 的最大值，memtable 的大小从  256KB 开始分配，每次新建则翻倍直到达到该阈值，默认是 4MB</span></span><br><span class="line">MemTableStopWritesThreshold <span class="comment">// 所有 memtable 总大小达到  MemTableStopWritesThreshold*MemTableSize 会阻塞写，默认值是 2</span></span><br><span class="line">MaxConcurrentCompactions <span class="comment">// 最大 compaction 并发数，默认值是 1，具体用处等到后面将 compaction 时再详细展开</span></span><br><span class="line">ReadOnly <span class="comment">// DB 以只读方式打开，后台的 compaction 和 flush 会关闭</span></span><br></pre></td></tr></table></figure>

<p>了解上述基本配置项后，现在可以正式进入写入流程。这里展示不分析 Open 流程，等介绍完前几章内容再倒过来分析会更容易理解。我们直接从 DB.Set 开始。</p>
<h4 id="DB-Set"><a href="#DB-Set" class="headerlink" title="DB.Set"></a>DB.Set</h4><p>数据的写入方式有两种，一种是单 KV 写入，另一种是 Batch 批量写入。单 KV 写入也会转为 Batch 方式，因此我们以 DB.Set 方法为入口来看看里面的实现逻辑。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *DB)</span></span> Set(key, value []<span class="type">byte</span>, opts *WriteOptions) <span class="type">error</span> &#123;</span><br><span class="line">	b := newBatch(d)</span><br><span class="line">	_ = b.Set(key, value, opts)</span><br><span class="line">	<span class="keyword">if</span> err := d.Apply(b, opts); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Only release the batch on success.</span></span><br><span class="line">	b.release()</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，Set 方法内部会新建一个 Batch，并将 KV 塞入到 Batch，然后执行 DB 的 Apply 方法，如果成功执行则调用 release 释放 Batch。这里讲到 Batch，那我们来看看 Batch 的格式到底长啥样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|-        header       -|-  body -|</span><br><span class="line">+-----------+-----------+----...--+</span><br><span class="line">|SeqNum (8B)| Count (4B)| Entries |</span><br><span class="line">+-----------+-----------+---------+</span><br></pre></td></tr></table></figure>

<p>Batch 内部数据由 header 和 body 组成，header 包含 8 字节 SeqNum 和 4 字节 Count，SeqNum 表示 batch 的序列号，Count 表示 Entry 个数。body 由多个 Entry 构成。每个 Entry 格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+----------+--------+-----+----------+-------+</span><br><span class="line">|Kind (1B) | KeyLen | Key | ValueLen | Value |</span><br><span class="line">+----------+--------+-----+----------+-------+</span><br></pre></td></tr></table></figure>

<p>Kind 表示 Entry 的类型，如 SET、DELETE、MERGE 等，这里写入的类型为 SET。KeyLen 表示 Key 的大小，为 VInt 类型，最大 4 字节，Key 即为 KeyLen 字节序列，同理，ValueLen 表示 Value 大小，为 VInt 类型，最大 4 字节，Value 为 ValueLen 字节序列。  </p>
<p>了解完 Batch 格式后，我们继续往下走，这里直接进入到 DB 的 Apply 方法。</p>
<h4 id="DB-Apply"><a href="#DB-Apply" class="headerlink" title="DB.Apply"></a>DB.Apply</h4><p>Apply 方法里面会做一些检验工作，随后将 Batch 提交写入，这里贴部分关键代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="type">int</span>(batch.memTableSize) &gt;= d.largeBatchThreshold &#123;</span><br><span class="line">	batch.flushable = newFlushableBatch(batch, d.opts.Comparer)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := d.commit.Commit(batch, sync); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="comment">// There isn&#x27;t much we can do on an error here. The commit pipeline will be</span></span><br><span class="line">	<span class="comment">// horked at this point.</span></span><br><span class="line">	d.opts.Logger.Fatalf(<span class="string">&quot;%v&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先会判断 batch 的大小，如果超过最大 large batch 的阈值，则该 batch 被视为 large batch，需要特殊处理。为了避免本章内容过于繁杂，本章后面所有涉及 large batch 的逻辑都将省略，下章会单独对 large batch 进行讲解。下面我们直接进入 Commit 方法。</p>
<h4 id="commitPipeline-Commit"><a href="#commitPipeline-Commit" class="headerlink" title="commitPipeline.Commit"></a>commitPipeline.Commit</h4><p>笔者认为 Commit 方法是写入流程中非常核心的方法，里面体现了 Pebble 高性能设计之道。我们先来看看代码（该方法不算特别长，全部奉上）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *commitPipeline)</span></span> Commit(b *Batch, syncWAL <span class="type">bool</span>) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> b.Empty() &#123; <span class="keyword">return</span> <span class="literal">nil</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 并发控制，sem 是缓冲 channel，因此可以并发 commit</span></span><br><span class="line">	p.sem &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// prepare 主要做的事情：1. 准备好可用的 memtable 2. 写 wal(可以是异步的，将 wal 塞入 queue, 再异步写，提高并发性能)</span></span><br><span class="line">	<span class="comment">// prepare 中会对 pipeline 加锁，因此整个过程是串行执行，不过该函数通常很快</span></span><br><span class="line">	mem, err := p.prepare(b, syncWAL)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		b.db = <span class="literal">nil</span> <span class="comment">// prevent batch reuse on error</span></span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将 batch 写入 memtable，这里可以是并发执行，该流程是 pipeline 中最耗的</span></span><br><span class="line">	<span class="keyword">if</span> err := p.env.apply(b, mem); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		b.db = <span class="literal">nil</span> <span class="comment">// prevent batch reuse on error</span></span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Publish the batch sequence number.</span></span><br><span class="line">	p.publish(b)</span><br><span class="line"></span><br><span class="line">	&lt;-p.sem</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> b.commitErr != <span class="literal">nil</span> &#123;</span><br><span class="line">		b.db = <span class="literal">nil</span> <span class="comment">// prevent batch reuse on error</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b.commitErr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Commit 方法包含三个核心步骤，首先是通过 <strong>prepare</strong> 方法准备好可用的 Memtable，并将数据异步写入 Wal，整个 prepare 方法会加锁，因此该方法只能串行执行，但是该方法执行较快，时间复杂度为 <em>O(1)</em> ；然后调用 <strong>apply</strong> 方法将 batch 写入 Memtable，由于 Memtable 采用无锁 Skiplist 实现，可以并发执行，但是该流程相对更耗，时间复杂度为 *nO(logm)*（n 为 Batch 记录条数，m 为 Memtable 中 key 数目）；最后调用 <strong>publish</strong> 方法将 batch 的 SeqNum 发布出去使其可见，换句话说，就是让提交的数据可读，该函数可并发执行，如果 Wal 为异步落盘，该方法会比较快。在多线程场景下，这三个阶段会被组织成 Pipleline 方式处理，我们先根据下图来直观感受下 Pipeline 的执行过程：</p>
<p><img src="/images/pebble/pipeline.png" alt="pipeline"></p>
<p>如上图，假设有多个线程并发执行 Commit，只有 prepare 阶段间多个线程是串行执行，其他阶段是可以并发执行的，这种思想和处理器指令流水线如出一辙。这种模型可以充分发挥现代 CPU 多核的优势。我们可以通过一个公式来计算下每个线程的平均耗时。假设每个线程的 prepare 阶段耗时为 <em>x</em>，apply 耗时为 <em>y</em>，publish 耗时为 <em>z</em>。则从第 1 个线程到第 n 个线程执行完毕，时间轴上总耗时为 <em>n</em> * <em>x+y+z</em>，每个线程的平均耗时为 <em>(n</em> * <em>x+y+z)&#x2F;n</em> &#x3D; <em>x+(y+z)&#x2F;n</em>。可以看出在理想情况下，并发量无穷大时，线程的平均执行时间趋近于 <em>x</em>，当然实际上线程数过多并不一定更优，因为线程切换也是有开销的，总的来说，在合理范围内，并发量越大系统吞吐也更大。</p>
<p>到这里，Pipeline 的设计思想就分析完成了。接下来我们再展开讲讲每个阶段的执行逻辑。</p>
<h4 id="commitPipeline-prepare"><a href="#commitPipeline-prepare" class="headerlink" title="commitPipeline.prepare"></a>commitPipeline.prepare</h4><p>prepare 方法主要是准备 batch 写入的 Memtable 及异步写 wal。主要代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">count := <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> syncWAL &#123;</span><br><span class="line">	count++</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// commit 为 sync.Group，用于等待 batch publish，如果 wal 为同步模式，也会等待 wal 刷盘</span></span><br><span class="line">b.commit.Add(count)</span><br><span class="line"></span><br><span class="line"> p.mu.Lock()</span><br><span class="line"><span class="comment">// 将 batch 如队列，保证并发场景下 batch 的顺序</span></span><br><span class="line">p.pending.enqueue(b)</span><br><span class="line"><span class="comment">// 设置 batch 的序列号，batch 的 n 条记录序列号递增</span></span><br><span class="line"> b.setSeqNum(atomic.AddUint64(p.env.logSeqNum, n) - n)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数据写入 wal</span></span><br><span class="line">mem, err := p.env.write(b, syncWG, syncErr)</span><br><span class="line"></span><br><span class="line">p.mu.Unlock()</span><br></pre></td></tr></table></figure>

<p>首先会根据 Wal 是否为同步模式来决定 commit 的等待计数，初始计数为 1，是因为必须等待 batch 的发布（后面 publish 方法中会看到），如果 Wal 为同步模式，还必须等待 Wal 刷盘完成。注意，这里只是计数，commit.Wait 会在 publish 中调用。</p>
<p>然后加锁进入临界区，在临界区内，先将 batch 入队列；然后给 batch 分配递增的序列号，由于外面有上锁，因此在并发环境下，batch 在队列中的顺序和 SeqNum 的顺序关系一致，即先入队列的 SeqNum 越小；最后将数据写入 wal。这里的 write 方法其实是 DB.commitWrite，我们来看下写入的逻辑。</p>
<h5 id="DB-commitWrite"><a href="#DB-commitWrite" class="headerlink" title="DB.commitWrite"></a>DB.commitWrite</h5><p>这个方法里面会执行两个核心的操作：1. 准备 batch 的 Memtable；2. 将数据写入到日志的内存结构中。贴下关键代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 batch 的底层字节数组数据</span></span><br><span class="line"> repr := b.Repr()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上锁，操作 memtable</span></span><br><span class="line">d.mu.Lock()</span><br><span class="line">err := d.makeRoomForWrite(b)</span><br><span class="line">mem := d.mu.mem.mutable</span><br><span class="line">d.mu.Unlock()</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 如果 wal 未开启，直接返回 memtable</span></span><br><span class="line"><span class="keyword">if</span> d.opts.DisableWAL &#123;</span><br><span class="line">	<span class="keyword">return</span> mem, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数据写入 wal 内存结构</span></span><br><span class="line"><span class="keyword">if</span> b.flushable == <span class="literal">nil</span> &#123;</span><br><span class="line">	size, err = d.mu.log.SyncRecord(repr, syncWG, syncErr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>makeRoomForWrite  主要是为了确保当前 Memtable 是否足以容纳 batch 的数据，如果当前 Memtable 容量已经满了，会将其转变为 Immutable 并重新创建 Memtable。由于 makeRoomForWrite 会对 memtable 和 log 进行操作，因此这里会加锁，该方法执行逻辑比较复杂，这里不详细展开，我们放到下章和 large batch 一起讲解。</p>
<p>如果开启了 Wal，会将数据写入日志内存结构。这里我们来看看日志的格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|-                      header                    -|-  body   -|</span><br><span class="line">+---------+-----------+-----------+----------------+--- ... ---+</span><br><span class="line">|CRC (4B) | Size (2B) | Type (1B) | Log number (4B)| Payload   |</span><br><span class="line">+---------+-----------+-----------+----------------+--- ... ---+</span><br></pre></td></tr></table></figure>

<p>日志由 header 和 body 构成。header 包含 4 字节 CRC 校验码，2 字节 Size 表示 body 的大小，1 字节 Type 表示日志处在 block 中的位置，后面详细解释， 4 字节 LogNum 表示日志文件的编号，可用于日志复用，这个后面章节再详解；payload 表示日志的内容，在这里即为 Batch 的字节数组数据。</p>
<p>日志是按照 32KB 的 Block 来存放的，如下图所示：</p>
<img src="/images/pebble/log-block.png" alt="image-20220123122255184" style="zoom:50%;" />

<p>如果一条日志比较小，足以放入到 1 个 Block 中，此时 Type 即为 <em>full</em>，如果一条日志比较大，那么 1 个 Block 无法放入，那么一条日志便会切分成多个片段跨多个 Block 存放，第一个片段的 Type 为 <em>first</em>，中间片段的 Type 为 <em>middle</em>，最后一个片段的 Type 为 <em>last</em>。读取日志时，便可根据 Type 将日志组装还原。</p>
<p>有了上面对日志格式的讲解，我们再看 SyncRecord 方法就比较容易了，LogWriter.SyncRecord 的代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *LogWriter)</span></span> SyncRecord(p []<span class="type">byte</span>, wg *sync.WaitGroup, err *<span class="type">error</span>) (<span class="type">int64</span>, <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="comment">// 切分数据放到片段中</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i == <span class="number">0</span> || <span class="built_in">len</span>(p) &gt; <span class="number">0</span>; i++ &#123;</span><br><span class="line">		p = w.emitFragment(i, p)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// wg 不为空，则表示 wal 是同步落盘，因此需要通知 flusher 去刷盘</span></span><br><span class="line">	<span class="keyword">if</span> wg != <span class="literal">nil</span> &#123;</span><br><span class="line">		f := &amp;w.flusher</span><br><span class="line">		f.syncQ.push(wg, err)</span><br><span class="line">		f.ready.Signal()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	offset := w.blockNum*blockSize + <span class="type">int64</span>(w.block.written)</span><br><span class="line">	<span class="keyword">return</span> offset, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SyncRecord 方法还是比较好理解，for 循环中便会将数据按照上面讲的方式切分片段，并将片段写入 block 中。如果日志为同步落盘方式，还会通知 flusher 去刷盘，同时会将 wg 放到 sync 队列，flusher 会通过 wg 异步通知 Pipeline 刷盘完成。</p>
<p>到这里，通过 prepare 阶段已经将 Memtable 准备完毕，同时讲数据写入到 Wal 内存 Block 中，Pipeline 流程便会拿着准备好的 Memtable 进行写入操作，我们继续看下一个阶段 apply。</p>
<h4 id="commitPipeline-commitEnv-apply"><a href="#commitPipeline-commitEnv-apply" class="headerlink" title="commitPipeline.commitEnv.apply"></a>commitPipeline.commitEnv.apply</h4><p>上一阶段已经准备好 Memtable，在 apply 阶段便会将 batch 写入到 Memtable 中。apply 的代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *DB)</span></span> commitApply(b *Batch, mem *memTable) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// 写入 memtable，无锁</span></span><br><span class="line">  err := mem.apply(b, b.SeqNum())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">	<span class="keyword">if</span> mem.writerUnref() &#123;</span><br><span class="line">		d.mu.Lock()</span><br><span class="line">		d.maybeScheduleFlush()</span><br><span class="line">		d.mu.Unlock()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里省略了部分代码，commitAppy 方法中，首先会将 batch 写入 memtable，memtable 内部是无锁 Skiplist，支持并发读写；写入完毕后释放 memtable 的写引用，最后调用 DB.maybeScheduleFlush 决定是否将 memtable flush 到磁盘，该方法是异步执行的，因此临界区耗时较短，flush 的流程我们放到后面剖析 compaction 的章节去讲。</p>
<p>apply 完毕后，数据就已经成功写入到 memtable 中，这时候写入流程还并未结束，数据还不能读取到。我们继续看下一阶段 publish。</p>
<h4 id="commitPipeline-publish"><a href="#commitPipeline-publish" class="headerlink" title="commitPipeline.publish"></a>commitPipeline.publish</h4><p>回顾下 prepare 阶段，batch 的 commit 被计数，commit 为 sync.Group，主要用途是：1. Wal 如果是同步落盘，需等待 wal 落盘完毕；2. 等待 batch 的 SeqNum 被发布。接下来看看 publish 的实现逻辑：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *commitPipeline)</span></span> publish(b *Batch) &#123;</span><br><span class="line">	<span class="comment">// 标记当前 batch 已经 apply</span></span><br><span class="line">	atomic.StoreUint32(&amp;b.applied, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// 从队列取出 batch，该 batch 可能是当前 batch，也可能是其他线程提交的 batch</span></span><br><span class="line">		t := p.pending.dequeue()</span><br><span class="line">		<span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// 关键，1. 等待 SeqNum 被发布 2. 如果 wal 同步落盘等待 flusher 通知落盘</span></span><br><span class="line">			b.commit.Wait()</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> atomic.LoadUint32(&amp;t.applied) != <span class="number">1</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">&quot;not reached&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过循环 + cas 的方式更新当前可见的 SeqNum</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			curSeqNum := atomic.LoadUint64(p.env.visibleSeqNum)</span><br><span class="line">			newSeqNum := t.SeqNum() + <span class="type">uint64</span>(t.Count())</span><br><span class="line">			<span class="keyword">if</span> newSeqNum &lt;= curSeqNum &#123;</span><br><span class="line">				<span class="comment">// t&#x27;s sequence number has already been published.</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> atomic.CompareAndSwapUint64(p.env.visibleSeqNum, curSeqNum, newSeqNum) &#123;</span><br><span class="line">				<span class="comment">// We successfully published t&#x27;s sequence number.</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		t.commit.Done()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行到 publish 方法，说明当前 batch <em><strong>b</strong></em> 已经被 appy 到 Memtable 中了，这里先将其标记为 applied 状态，然后从队列取出队头 batch，注意：1. 取出的 batch 有可能是当前线程对应的 batch，也有可能是其他线程的 batch；2. 如果队头 batch 并未 apply，则其并不会出队列，同时返回 nil 。如果返回的是 nil，则调用 commit.Wait 等待 SeqNum 发布和 Wal 落盘，否则，通过循环 + CAS 的方式更新整个 DB 的 visibleSeqNum。</p>
<p>我们看下第二层 for 循环中更新 visibleSeqNum 的逻辑，首先通过原子操作取出 visibleSeqNum，然后根据 <em><strong>t</strong></em> 计算新的 SeqNum，如果新的 SeqNum &lt; visibleSeqNum，说明有排在 <em><strong>t</strong></em>  后面的 batch 已经被其他线程 publish 了，那么 <em><strong>t</strong></em>  也就相当于 publish 了，直接退出循环，否则更新 visibleSeqNum。<em><strong>t</strong></em> 成功 publish 后调用 t.commit 将计数减一，而后回到第一层循环继续消费 pengding 队列。</p>
<p>可以看到，publish 设计得比较有意思，支持多个消费者同时消费 pending 队列，而且每个线程可以消费其他线程的 batch。这样做的好处是每个线程不必等着处理自己的 batch，多个线程可以接连不断地消费 pending 队列并独立 publish batch，充分利用多核优势提升性能。</p>
<p>到此，pipeline 的三个阶段便分析完成，整个写入流程也就结束了。下一章将继续补充写入路径上对 large batch 的特殊处理，以及详细讲解 makeRoomForWrite 的执行逻辑。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本章从源码角度出发，按照源码执行流程，对写入流程进行了剖析并着重讲解了 Pipeline 的三个阶段。Pebble 利用 Pipeline、异步处理、CAS 无锁编程、多线程等多种技术手段打造出了高效的写入性能。本章并未覆盖到所有细节点，欢迎感兴趣的同学多多交流。</p>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#Pebble" >
    <span class="tag-code">Pebble</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2022/01/20/2022-01-20-intr-pebble/">
        <span class="nav-arrow">← </span>
        
          初识Pebble
        
      </a>
    
    
      <a class="nav-right" href="/2022/01/27/2022-01-27-compaction-size-tiered/">
        
          Compaction 策略 - Size-Tiered
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
    <!-- 二维码 END -->
    
      <!-- Gitment START -->
      <div id="comments"></div>
      <!-- Gitment END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86"><span class="toc-nav-text">预备知识</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#WAL"><span class="toc-nav-text">WAL</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#Memtable"><span class="toc-nav-text">Memtable</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#SSTable"><span class="toc-nav-text">SSTable</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-nav-text">源码分析</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#DB-Set"><span class="toc-nav-text">DB.Set</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#DB-Apply"><span class="toc-nav-text">DB.Apply</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#commitPipeline-Commit"><span class="toc-nav-text">commitPipeline.Commit</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#commitPipeline-prepare"><span class="toc-nav-text">commitPipeline.prepare</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#DB-commitWrite"><span class="toc-nav-text">DB.commitWrite</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#commitPipeline-commitEnv-apply"><span class="toc-nav-text">commitPipeline.commitEnv.apply</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#commitPipeline-publish"><span class="toc-nav-text">commitPipeline.publish</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-nav-text">总结</span></a></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'https://zhenyuxie.github.io/2022/01/24/2022-01-24-pebble_write_src/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', '/css/images/error_icon.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== '/css/images/error_icon.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>




  <script>
    var gitmentConfig = "zhenyuyxie";
    if (gitmentConfig !== 'undefined') {
      var gitment = new Gitment({
        id: "Pebble 源码剖析-写入流程",
        owner: "zhenyuyxie",
        repo: "zhenyuxie.github.io",
        oauth: {
          client_id: "1f2036d171d35790250b",
          client_secret: "d1f9e1ae4ea60f6783f5dace256aec77eed5d99b"
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  </script>




    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2023 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      hljs.configure({useBR: true});
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/js/script.js"></script>


  </body>
</html>