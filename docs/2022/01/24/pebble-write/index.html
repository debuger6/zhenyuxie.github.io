<!doctype html><html lang=zh-cn data-theme=light><head><meta charset=utf-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: light)"><meta name=generator content="Hugo 0.109.0"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_16x16_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_32_32_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="Pebble 源码剖析-写入流程"><meta itemprop=description content="Pebble 是 Cockroach  参考 RocksDB 并用 Go 语言开发的高性能 KV 存储引擎."><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="/imgs/hugo_next_avatar.png"><meta itemprop=keywords content="Pebble"><meta property="og:type" content="article"><meta property="og:title" content="Pebble 源码剖析-写入流程"><meta property="og:description" content="Pebble 是 Cockroach  参考 RocksDB 并用 Go 语言开发的高性能 KV 存储引擎."><meta property="og:image" content="/imgs/hugo_next_avatar.png"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="/2022/01/24/pebble-write/"><meta property="og:site_name" content="debuger"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="ZhenyuXie"><meta property="article:published_time" content="2022-01-24 00:00:04 +0000 UTC"><meta property="article:modified_time" content="2022-01-24 00:00:04 +0000 UTC"><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/font-awesome/6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.css><link rel=stylesheet href=/css/main.min.be6c851626019e2e94c69b61774cfd7d7e6d51aa8bde23336e90a17d2eea6de3.css><style type=text/css>.post-footer,.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":true,"isHome":false,"isPage":true,"path":"pebble-write","permalink":"/2022/01/24/pebble-write/","title":"Pebble 源码剖析-写入流程","waline":{"js":[{"alias":"waline","alias_name":"@waline/client","file":"dist/pageview.js","name":"pageview","version":"2.13.0"},{"alias":"waline","alias_name":"@waline/client","file":"dist/comment.js","name":"comment","version":"2.13.0"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>Pebble 源码剖析-写入流程 - debuger</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label="Toggle navigation bar" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>debuger</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>大道至简</p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about.html class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>技术博客
<span class=badge>9</span></a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>Search</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=Searching... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>TOC</li><li class=sidebar-nav-overview>Overview</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><ul><li><a href=#预备知识>预备知识</a><ul><li><a href=#wal>WAL</a></li><li><a href=#memtable>Memtable</a></li><li><a href=#sstable>SSTable</a></li></ul></li><li><a href=#源码分析>源码分析</a><ul><li><a href=#dbset>DB.Set</a></li><li><a href=#dbapply>DB.Apply</a></li><li><a href=#commitpipelinecommit>commitPipeline.Commit</a></li><li><a href=#commitpipelineprepare>commitPipeline.prepare</a></li><li><a href=#commitpipelinecommitenvapply>commitPipeline.commitEnv.apply</a></li><li><a href=#commitpipelinepublish>commitPipeline.publish</a></li></ul></li><li><a href=#总结>总结</a></li></ul></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=debuger src=/imgs/img-lazy-loading.gif data-src=/imgs/hugo_next_avatar.png><p class=site-author-name itemprop=name>debuger</p><div class=site-description itemprop=description>Simple is the best.</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>9</span>
<span class=site-state-item-name>Posts</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>5</span>
<span class=site-state-item-name>Categories</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>5</span>
<span class=site-state-item-name>Tags</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/zhenyuxie title="Github → https://github.com/zhenyuxie" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>Github</a></span>
<span class=links-of-social-item><a href=https://www.zhihu.com/people/xzy-51-38 title="知乎 → https://www.zhihu.com/people/xzy-51-38" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-book fa-fw hvr-icon"></i>知乎</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title="Creative Commons"><img src=/imgs/img-lazy-loading.gif data-src=/imgs/cc/big/by_nc_sa.svg alt="Creative Commons"></a></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>Web Status</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>Running:</div><div class=item-count id=runTimes data-publishdate=2022-01-20T22:00:00+00:00></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>Visitors:</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>Views:</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>Words:</div><div class=item-count id=wordsCount data-count=22597></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>ReadTime:</div><div class=item-count id=readTimes data-times=50></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>Last Update:</div><div class=item-count id=last-push-date data-lastpushdate=2023-02-15T22:00:00+08:00></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-comments class="button goto-comments" title="Go to Comment"><i class="fas fa-comments"></i></div><div id=goto-gtranslate class=button title="Multilingual translation"><i class="fas fa-globe"></i></div><div id=toggle-theme class=button title="Change Theme"><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title="Back to Top"><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a>
<a href=https://github.com/zhenyuxie rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><script type=text/javascript src=//sidecar.gitter.im/dist/sidecar.v1.js async></script>
<script type=text/javascript>((window.gitter={}).chat={}).options={room:"hugo-next/community"}</script><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=/2022/01/24/pebble-write/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/hugo_next_avatar.png"><meta itemprop=name content="ZhenyuXie"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="debuger"><meta itemprop=description content="Simple is the best."></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="Pebble 源码剖析-写入流程"><meta itemprop=description content="Pebble 是 Cockroach  参考 RocksDB 并用 Go 语言开发的高性能 KV 存储引擎."></span><header class=post-header><h1 class=post-title itemprop="name headline">Pebble 源码剖析-写入流程</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i></span>
<span class=post-meta-item-text>Publish on:</span>
<time title="Publish on:2022-01-24 00:00:04 +0000 UTC" itemprop="dateCreated datePublished" datetime="2022-01-24 00:00:04 +0000 UTC">2022-01-24</time></span>
<span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i></span>
<span class=post-meta-item-text>Classify at:</span>
<span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/pebble itemprop=url rel=index><span itemprop=name>pebble</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=Words><span class=post-meta-item-icon><i class="far fa-file-word"></i></span>
<span class=post-meta-item-text>Words:</span><span>5360</span></span>
<span class=post-meta-item title=Read><span class=post-meta-item-icon><i class="far fa-clock"></i></span>
<span class=post-meta-item-text>Read:&ap;</span>
<span>11min</span></span>
<span class=post-meta-item title=Views><span class=post-meta-item-icon><i class="far fa-eye"></i></span>
<span class=post-meta-item-text>Views:</span>
<span id=busuanzi_value_page_pv class=waline-pageview-count data-path=/2022/01/24/pebble-write/><i class="fa fa-sync fa-spin"></i></span></span>
<span class=post-meta-item title=Comments><span class=post-meta-item-icon><i class="far fa-comments"></i></span>
<span class=post-meta-item-text>Comments:</span>
<span class=waline-comment-count data-path=/2022/01/24/pebble-write/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>本章会结合 Pebble 源码来剖析整个写入流程，并会深入分析整个写入路径上涉及的一些技术细节。这里说明，文章只会贴一些关键代码和代码行数较少的函数或者方法，尽量避免太多代码内容影响阅读感受。</p><h3 id=预备知识>预备知识</h3><p>为了便于大家理解，首先会科普一些基础概念，有基础的同学可以直接跳过。为了更直观的理解，我们先将
<a href=https://zhenyuxie.github.io/2022/01/20/pebble-intr/ title=上一章 rel="noopener external nofollow noreferrer" target=_blank class=exturl>上一章
<i class="fa fa-external-link-alt"></i>
</a>的图搬过来。</p><p><img src=/imgs/img-lazy-loading.gif data-src=/images/pebble/LSM.png alt=LSM></p><h4 id=wal>WAL</h4><p>Wal（Write ahead of log）即预写日志，其是一种日志结构，每条日志包含了数据的原始内容并以追加写的方式写入磁盘文件，在数据写入内存前需将原始数据写入到 Wal。Wal 的写入模式可以分为 Sync（同步）和 Async（异步），如果为同步写则前台需阻塞等待日志落盘，异步写只需将日志记录写到内存缓存后便可返回。因此，同步模式可靠性更高但性能偏低，异步模式性能很好但有丢数据的风险，需根据具体场景合理选择使用哪种模式。Wal 的具体格式会在下面源码分析阶段详细介绍。</p><h4 id=memtable>Memtable</h4><p>Memtable 是数据（KV Pairs）在内存中的载体，业务数据写入 Pebble 后，首先写 Wal，然后会写入到 Memtable，数据在 Memtable 中会按序存储。Memtable 有两种形式，一种是 Mutable Memtable（可变），另外一种是 Immutable Memtable（不可变），顾名思义，前者可以同时支持读写，而后者只能读不能写。Memtable（默认指是 Mutable）一般会有大小限制，写满后会转变为 Immutable，Immutable 会由专门后台线程按照某种策略刷到磁盘，同时释放内存并清理对应的 Wal。</p><h4 id=sstable>SSTable</h4><p>SSTable 即 Sorted String Table 简称为 SST，由内存中的 Memtable 刷盘而成，是一种有序的、不修改的磁盘文件格式，其中 Key 和 Value 都可以是任意的 byte 序列。和 RocksDB/LevelDB 一样，SST 在 Pebble 中也是按层组织，数据首先刷入到第 0 层，在到达一定数量后后被后台线程 Merge 并 Compact 到下层。每层的数据量按倍数增长，越往下层数据量越大，同时数据也越老。</p><p>由于本章只分析写入流程，因此我们先科普上述三个比较重要的概念，其他知识后面涉及再详细展开。</p><h3 id=源码分析>源码分析</h3><p>有了上面的预备知识，本节可以开始对源码进行剖析了。首先贴上官方的 Demo 程序：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;log&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;github.com/cockroachdb/pebble&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>db</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>pebble</span>.<span style=color:#a6e22e>Open</span>(<span style=color:#e6db74>&#34;demo&#34;</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>pebble</span>.<span style=color:#a6e22e>Options</span>{})
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>key</span> <span style=color:#f92672>:=</span> []byte(<span style=color:#e6db74>&#34;hello&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Set</span>(<span style=color:#a6e22e>key</span>, []byte(<span style=color:#e6db74>&#34;world&#34;</span>), <span style=color:#a6e22e>pebble</span>.<span style=color:#a6e22e>Sync</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>value</span>, <span style=color:#a6e22e>closer</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#a6e22e>key</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;%s %s\n&#34;</span>, <span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>value</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>closer</span>.<span style=color:#a6e22e>Close</span>(); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Close</span>(); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可以看到 Pebble 的使用还是比较简单，首先根据配置项打开一个 DB，然后便可以向该 DB 进行读写操作了。这里顺便介绍配置项 Options 的一些常用且重要的选项，便于后续理解。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>BytesPerSync</span> <span style=color:#75715e>// 控制 sstable 按照该值平滑刷盘，防止系统一次性刷大量脏页导致写入延时抖动，默认值是 512KB
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>WALBytesPerSync</span> <span style=color:#75715e>// 控制 wal 按照该值平滑刷盘，不过 Pebble 认为该值一般情况下没必要设置，因为大部分场景 wal 是 sync 写入的，默认值是 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>DisableWAL</span> <span style=color:#75715e>// 是否关闭 Wal，该参数为 true 时，不写 Wal，数据可靠性最低，默认为 false
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>L0CompactionThreshold</span> <span style=color:#75715e>// level 0 读放大 compaction 阈值，到达阈值后将触发 L0 compaction，默认值是 4
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>L0StopWritesThreshold</span> <span style=color:#75715e>// level 0 的读放大停写阈值，达到阈值后将阻塞写，默认值是 12
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>LBaseMaxBytes</span> <span style=color:#75715e>// level 0 compaction 至的 level 最大容量，其他层的最大容量会根据该值动态计算，默认是 64 MB
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>MemTableSize</span>  <span style=color:#75715e>// memtable 的最大值，memtable 的大小从  256KB 开始分配，每次新建则翻倍直到达到该阈值，默认是 4MB
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>MemTableStopWritesThreshold</span> <span style=color:#75715e>// 所有 memtable 总大小达到  MemTableStopWritesThreshold*MemTableSize 会阻塞写，默认值是 2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>MaxConcurrentCompactions</span> <span style=color:#75715e>// 最大 compaction 并发数，默认值是 1，具体用处等到后面将 compaction 时再详细展开
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>ReadOnly</span> <span style=color:#75715e>// DB 以只读方式打开，后台的 compaction 和 flush 会关闭
</span></span></span></code></pre></div><p>了解上述基本配置项后，现在可以正式进入写入流程。这里展示不分析 Open 流程，等介绍完前几章内容再倒过来分析会更容易理解。我们直接从 DB.Set 开始。</p><h4 id=dbset>DB.Set</h4><p>数据的写入方式有两种，一种是单 KV 写入，另一种是 Batch 批量写入。单 KV 写入也会转为 Batch 方式，因此我们以 DB.Set 方法为入口来看看里面的实现逻辑。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>d</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>DB</span>) <span style=color:#a6e22e>Set</span>(<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>value</span> []<span style=color:#66d9ef>byte</span>, <span style=color:#a6e22e>opts</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>WriteOptions</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>newBatch</span>(<span style=color:#a6e22e>d</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Set</span>(<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>value</span>, <span style=color:#a6e22e>opts</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>Apply</span>(<span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>opts</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Only release the batch on success.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>release</span>()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可以看到，Set 方法内部会新建一个 Batch，并将 KV 塞入到 Batch，然后执行 DB 的 Apply 方法，如果成功执行则调用 release 释放 Batch。这里讲到 Batch，那我们来看看 Batch 的格式到底长啥样。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>|-        header       -|-  body -|
</span></span><span style=display:flex><span>+-----------+-----------+----...--+
</span></span><span style=display:flex><span>|SeqNum (8B)| Count (4B)| Entries |
</span></span><span style=display:flex><span>+-----------+-----------+---------+
</span></span></code></pre></div><p>Batch 内部数据由 header 和 body 组成，header 包含 8 字节 SeqNum 和 4 字节 Count，SeqNum 表示 batch 的序列号，Count 表示 Entry 个数。body 由多个 Entry 构成。每个 Entry 格式如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>+----------+--------+-----+----------+-------+
</span></span><span style=display:flex><span>|Kind (1B) | KeyLen | Key | ValueLen | Value |
</span></span><span style=display:flex><span>+----------+--------+-----+----------+-------+
</span></span></code></pre></div><p>Kind 表示 Entry 的类型，如 SET、DELETE、MERGE 等，这里写入的类型为 SET。KeyLen 表示 Key 的大小，为 VInt 类型，最大 4 字节，Key 即为 KeyLen 字节序列，同理，ValueLen 表示 Value 大小，为 VInt 类型，最大 4 字节，Value 为 ValueLen 字节序列。</p><p>了解完 Batch 格式后，我们继续往下走，这里直接进入到 DB 的 Apply 方法。</p><h4 id=dbapply>DB.Apply</h4><p>Apply 方法里面会做一些检验工作，随后将 Batch 提交写入，这里贴部分关键代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span>	<span style=color:#66d9ef>if</span> int(<span style=color:#a6e22e>batch</span>.<span style=color:#a6e22e>memTableSize</span>) <span style=color:#f92672>&gt;=</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>largeBatchThreshold</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>batch</span>.<span style=color:#a6e22e>flushable</span> = <span style=color:#a6e22e>newFlushableBatch</span>(<span style=color:#a6e22e>batch</span>, <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>opts</span>.<span style=color:#a6e22e>Comparer</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>commit</span>.<span style=color:#a6e22e>Commit</span>(<span style=color:#a6e22e>batch</span>, <span style=color:#a6e22e>sync</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// There isn&#39;t much we can do on an error here. The commit pipeline will be
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// horked at this point.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>opts</span>.<span style=color:#a6e22e>Logger</span>.<span style=color:#a6e22e>Fatalf</span>(<span style=color:#e6db74>&#34;%v&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><p>首先会判断 batch 的大小，如果超过最大 large batch 的阈值，则该 batch 被视为 large batch，需要特殊处理。为了避免本章内容过于繁杂，本章后面所有涉及 large batch 的逻辑都将省略，下章会单独对 large batch 进行讲解。下面我们直接进入 Commit 方法。</p><h4 id=commitpipelinecommit>commitPipeline.Commit</h4><p>笔者认为 Commit 方法是写入流程中非常核心的方法，里面体现了 Pebble 高性能设计之道。我们先来看看代码（该方法不算特别长，全部奉上）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>commitPipeline</span>) <span style=color:#a6e22e>Commit</span>(<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Batch</span>, <span style=color:#a6e22e>syncWAL</span> <span style=color:#66d9ef>bool</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Empty</span>() { <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 并发控制，sem 是缓冲 channel，因此可以并发 commit
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>sem</span> <span style=color:#f92672>&lt;-</span> <span style=color:#66d9ef>struct</span>{}{}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// prepare 主要做的事情：1. 准备好可用的 memtable 2. 写 wal(可以是异步的，将 wal 塞入 queue, 再异步写，提高并发性能)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// prepare 中会对 pipeline 加锁，因此整个过程是串行执行，不过该函数通常很快
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>mem</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>prepare</span>(<span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>syncWAL</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>db</span> = <span style=color:#66d9ef>nil</span> <span style=color:#75715e>// prevent batch reuse on error
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 将 batch 写入 memtable，这里可以是并发执行，该流程是 pipeline 中最耗的
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>env</span>.<span style=color:#a6e22e>apply</span>(<span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>mem</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>db</span> = <span style=color:#66d9ef>nil</span> <span style=color:#75715e>// prevent batch reuse on error
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Publish the batch sequence number.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>publish</span>(<span style=color:#a6e22e>b</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>sem</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>commitErr</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>db</span> = <span style=color:#66d9ef>nil</span> <span style=color:#75715e>// prevent batch reuse on error
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>commitErr</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Commit 方法包含三个核心步骤，首先是通过 <strong>prepare</strong> 方法准备好可用的 Memtable，并将数据异步写入 Wal，整个 prepare 方法会加锁，因此该方法只能串行执行，但是该方法执行较快，时间复杂度为 <em>O(1)</em> ；然后调用 <strong>apply</strong> 方法将 batch 写入 Memtable，由于 Memtable 采用无锁 Skiplist 实现，可以并发执行，但是该流程相对更耗，时间复杂度为 <em>nO(logm)</em>（n 为 Batch 记录条数，m 为 Memtable 中 key 数目）；最后调用 <strong>publish</strong> 方法将 batch 的 SeqNum 发布出去使其可见，换句话说，就是让提交的数据可读，该函数可并发执行，如果 Wal 为异步落盘，该方法会比较快。在多线程场景下，这三个阶段会被组织成 Pipleline 方式处理，我们先根据下图来直观感受下 Pipeline 的执行过程：</p><p><img src=/imgs/img-lazy-loading.gif data-src=/images/pebble/pipeline.png alt=pipeline></p><p>如上图，假设有多个线程并发执行 Commit，只有 prepare 阶段间多个线程是串行执行，其他阶段是可以并发执行的，这种思想和处理器指令流水线如出一辙。这种模型可以充分发挥现代 CPU 多核的优势。我们可以通过一个公式来计算下每个线程的平均耗时。假设每个线程的 prepare 阶段耗时为 <em>x</em>，apply 耗时为 <em>y</em>，publish 耗时为 <em>z</em>。则从第 1 个线程到第 n 个线程执行完毕，时间轴上总耗时为 <em>n</em> * <em>x+y+z</em>，每个线程的平均耗时为 <em>(n</em> * <em>x+y+z)/n</em> = <em>x+(y+z)/n</em>。可以看出在理想情况下，并发量无穷大时，线程的平均执行时间趋近于 <em>x</em>，当然实际上线程数过多并不一定更优，因为线程切换也是有开销的，总的来说，在合理范围内，并发量越大系统吞吐也更大。</p><p>到这里，Pipeline 的设计思想就分析完成了。接下来我们再展开讲讲每个阶段的执行逻辑。</p><h4 id=commitpipelineprepare>commitPipeline.prepare</h4><p>prepare 方法主要是准备 batch 写入的 Memtable 及异步写 wal。主要代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span>	<span style=color:#a6e22e>count</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>syncWAL</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>count</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#75715e>// commit 为 sync.Group，用于等待 batch publish，如果 wal 为同步模式，也会等待 wal 刷盘
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>commit</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#a6e22e>count</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Lock</span>()
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 将 batch 如队列，保证并发场景下 batch 的顺序
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>pending</span>.<span style=color:#a6e22e>enqueue</span>(<span style=color:#a6e22e>b</span>)
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 设置 batch 的序列号，batch 的 n 条记录序列号递增
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>setSeqNum</span>(<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>AddUint64</span>(<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>env</span>.<span style=color:#a6e22e>logSeqNum</span>, <span style=color:#a6e22e>n</span>) <span style=color:#f92672>-</span> <span style=color:#a6e22e>n</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 将数据写入 wal
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>mem</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>env</span>.<span style=color:#a6e22e>write</span>(<span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>syncWG</span>, <span style=color:#a6e22e>syncErr</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span></code></pre></div><p>首先会根据 Wal 是否为同步模式来决定 commit 的等待计数，初始计数为 1，是因为必须等待 batch 的发布（后面 publish 方法中会看到），如果 Wal 为同步模式，还必须等待 Wal 刷盘完成。注意，这里只是计数，commit.Wait 会在 publish 中调用。</p><p>然后加锁进入临界区，在临界区内，先将 batch 入队列；然后给 batch 分配递增的序列号，由于外面有上锁，因此在并发环境下，batch 在队列中的顺序和 SeqNum 的顺序关系一致，即先入队列的 SeqNum 越小；最后将数据写入 wal。这里的 write 方法其实是 DB.commitWrite，我们来看下写入的逻辑。</p><h5 id=dbcommitwrite>DB.commitWrite</h5><p>这个方法里面会执行两个核心的操作：1. 准备 batch 的 Memtable；2. 将数据写入到日志的内存结构中。贴下关键代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span>	<span style=color:#75715e>// 获取 batch 的底层字节数组数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>repr</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Repr</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 上锁，操作 memtable
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Lock</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>makeRoomForWrite</span>(<span style=color:#a6e22e>b</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mem</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>mem</span>.<span style=color:#a6e22e>mutable</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 如果 wal 未开启，直接返回 memtable
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>opts</span>.<span style=color:#a6e22e>DisableWAL</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>mem</span>, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 将数据写入 wal 内存结构
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>flushable</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>size</span>, <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>SyncRecord</span>(<span style=color:#a6e22e>repr</span>, <span style=color:#a6e22e>syncWG</span>, <span style=color:#a6e22e>syncErr</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			panic(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><p>makeRoomForWrite 主要是为了确保当前 Memtable 是否足以容纳 batch 的数据，如果当前 Memtable 容量已经满了，会将其转变为 Immutable 并重新创建 Memtable。由于 makeRoomForWrite 会对 memtable 和 log 进行操作，因此这里会加锁，该方法执行逻辑比较复杂，这里不详细展开，我们放到下章和 large batch 一起讲解。</p><p>如果开启了 Wal，会将数据写入日志内存结构。这里我们来看看日志的格式：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>|-                      header                    -|-  body   -|
</span></span><span style=display:flex><span>+---------+-----------+-----------+----------------+--- ... ---+
</span></span><span style=display:flex><span>|CRC (4B) | Size (2B) | Type (1B) | Log number (4B)| Payload   |
</span></span><span style=display:flex><span>+---------+-----------+-----------+----------------+--- ... ---+
</span></span></code></pre></div><p>日志由 header 和 body 构成。header 包含 4 字节 CRC 校验码，2 字节 Size 表示 body 的大小，1 字节 Type 表示日志处在 block 中的位置，后面详细解释， 4 字节 LogNum 表示日志文件的编号，可用于日志复用，这个后面章节再详解；payload 表示日志的内容，在这里即为 Batch 的字节数组数据。</p><p>日志是按照 32KB 的 Block 来存放的，如下图所示：</p><img src=/images/pebble/log-block.png alt=image-20220123122255184 style=zoom:50%><p>如果一条日志比较小，足以放入到 1 个 Block 中，此时 Type 即为 <em>full</em>，如果一条日志比较大，那么 1 个 Block 无法放入，那么一条日志便会切分成多个片段跨多个 Block 存放，第一个片段的 Type 为 <em>first</em>，中间片段的 Type 为 <em>middle</em>，最后一个片段的 Type 为 <em>last</em>。读取日志时，便可根据 Type 将日志组装还原。</p><p>有了上面对日志格式的讲解，我们再看 SyncRecord 方法就比较容易了，LogWriter.SyncRecord 的代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>w</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>LogWriter</span>) <span style=color:#a6e22e>SyncRecord</span>(<span style=color:#a6e22e>p</span> []<span style=color:#66d9ef>byte</span>, <span style=color:#a6e22e>wg</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>WaitGroup</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>error</span>) (<span style=color:#66d9ef>int64</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 切分数据放到片段中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> len(<span style=color:#a6e22e>p</span>) &gt; <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>p</span> = <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>emitFragment</span>(<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>p</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// wg 不为空，则表示 wal 是同步落盘，因此需要通知 flusher 去刷盘
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>wg</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>f</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>flusher</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>syncQ</span>.<span style=color:#a6e22e>push</span>(<span style=color:#a6e22e>wg</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>ready</span>.<span style=color:#a6e22e>Signal</span>()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>offset</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>blockNum</span><span style=color:#f92672>*</span><span style=color:#a6e22e>blockSize</span> <span style=color:#f92672>+</span> int64(<span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>block</span>.<span style=color:#a6e22e>written</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>offset</span>, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>SyncRecord 方法还是比较好理解，for 循环中便会将数据按照上面讲的方式切分片段，并将片段写入 block 中。如果日志为同步落盘方式，还会通知 flusher 去刷盘，同时会将 wg 放到 sync 队列，flusher 会通过 wg 异步通知 Pipeline 刷盘完成。</p><p>到这里，通过 prepare 阶段已经将 Memtable 准备完毕，同时讲数据写入到 Wal 内存 Block 中，Pipeline 流程便会拿着准备好的 Memtable 进行写入操作，我们继续看下一个阶段 apply。</p><h4 id=commitpipelinecommitenvapply>commitPipeline.commitEnv.apply</h4><p>上一阶段已经准备好 Memtable，在 apply 阶段便会将 batch 写入到 Memtable 中。apply 的代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>d</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>DB</span>) <span style=color:#a6e22e>commitApply</span>(<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Batch</span>, <span style=color:#a6e22e>mem</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>memTable</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 写入 memtable，无锁
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>mem</span>.<span style=color:#a6e22e>apply</span>(<span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>SeqNum</span>())
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>mem</span>.<span style=color:#a6e22e>writerUnref</span>() {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Lock</span>()
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>maybeScheduleFlush</span>()
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这里省略了部分代码，commitAppy 方法中，首先会将 batch 写入 memtable，memtable 内部是无锁 Skiplist，支持并发读写；写入完毕后释放 memtable 的写引用，最后调用 DB.maybeScheduleFlush 决定是否将 memtable flush 到磁盘，该方法是异步执行的，因此临界区耗时较短，flush 的流程我们放到后面剖析 compaction 的章节去讲。</p><p>apply 完毕后，数据就已经成功写入到 memtable 中，这时候写入流程还并未结束，数据还不能读取到。我们继续看下一阶段 publish。</p><h4 id=commitpipelinepublish>commitPipeline.publish</h4><p>回顾下 prepare 阶段，batch 的 commit 被计数，commit 为 sync.Group，主要用途是：1. Wal 如果是同步落盘，需等待 wal 落盘完毕；2. 等待 batch 的 SeqNum 被发布。接下来看看 publish 的实现逻辑：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>commitPipeline</span>) <span style=color:#a6e22e>publish</span>(<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Batch</span>) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 标记当前 batch 已经 apply
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>StoreUint32</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>applied</span>, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 从队列取出 batch，该 batch 可能是当前 batch，也可能是其他线程提交的 batch
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>pending</span>.<span style=color:#a6e22e>dequeue</span>()
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#75715e>// 关键，1. 等待 SeqNum 被发布 2. 如果 wal 同步落盘等待 flusher 通知落盘
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>commit</span>.<span style=color:#a6e22e>Wait</span>()
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>LoadUint32</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>applied</span>) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>			panic(<span style=color:#e6db74>&#34;not reached&#34;</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 通过循环 + cas 的方式更新当前可见的 SeqNum
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>curSeqNum</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>LoadUint64</span>(<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>env</span>.<span style=color:#a6e22e>visibleSeqNum</span>)
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>newSeqNum</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>SeqNum</span>() <span style=color:#f92672>+</span> uint64(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Count</span>())
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>newSeqNum</span> <span style=color:#f92672>&lt;=</span> <span style=color:#a6e22e>curSeqNum</span> {
</span></span><span style=display:flex><span>				<span style=color:#75715e>// t&#39;s sequence number has already been published.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>				<span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>CompareAndSwapUint64</span>(<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>env</span>.<span style=color:#a6e22e>visibleSeqNum</span>, <span style=color:#a6e22e>curSeqNum</span>, <span style=color:#a6e22e>newSeqNum</span>) {
</span></span><span style=display:flex><span>				<span style=color:#75715e>// We successfully published t&#39;s sequence number.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>				<span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>commit</span>.<span style=color:#a6e22e>Done</span>()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>执行到 publish 方法，说明当前 batch <em><strong>b</strong></em> 已经被 appy 到 Memtable 中了，这里先将其标记为 applied 状态，然后从队列取出队头 batch，注意：1. 取出的 batch 有可能是当前线程对应的 batch，也有可能是其他线程的 batch；2. 如果队头 batch 并未 apply，则其并不会出队列，同时返回 nil 。如果返回的是 nil，则调用 commit.Wait 等待 SeqNum 发布和 Wal 落盘，否则，通过循环 + CAS 的方式更新整个 DB 的 visibleSeqNum。</p><p>我们看下第二层 for 循环中更新 visibleSeqNum 的逻辑，首先通过原子操作取出 visibleSeqNum，然后根据 <em><strong>t</strong></em> 计算新的 SeqNum，如果新的 SeqNum &lt; visibleSeqNum，说明有排在 <em><strong>t</strong></em> 后面的 batch 已经被其他线程 publish 了，那么 <em><strong>t</strong></em> 也就相当于 publish 了，直接退出循环，否则更新 visibleSeqNum。<em><strong>t</strong></em> 成功 publish 后调用 t.commit 将计数减一，而后回到第一层循环继续消费 pengding 队列。</p><p>可以看到，publish 设计得比较有意思，支持多个消费者同时消费 pending 队列，而且每个线程可以消费其他线程的 batch。这样做的好处是每个线程不必等着处理自己的 batch，多个线程可以接连不断地消费 pending 队列并独立 publish batch，充分利用多核优势提升性能。</p><p>到此，pipeline 的三个阶段便分析完成，整个写入流程也就结束了。下一章将继续补充写入路径上对 large batch 的特殊处理，以及详细讲解 makeRoomForWrite 的执行逻辑。</p><h3 id=总结>总结</h3><p>本章从源码角度出发，按照源码执行流程，对写入流程进行了剖析并着重讲解了 Pipeline 的三个阶段。Pebble 利用 Pipeline、异步处理、CAS 无锁编程、多线程等多种技术手段打造出了高效的写入性能。本章并未覆盖到所有细节点，欢迎感兴趣的同学多多交流。</p></div><footer class=post-footer><div class=post-tags><a href=/tags/pebble>Pebble</a></div><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=reward-container><div><i class="fa-solid fa-mug-hot"></i>请我喝杯咖啡吧 ヾ(^▽^*)))</div><button>Donate</button><div class=post-reward><div class=post-reward-item><img src=/imgs/img-lazy-loading.gif data-src=/imgs/ali-pay.png alt="debuger - Alipay">
<span>Alipay</span></div><div class=post-reward-item><img src=/imgs/img-lazy-loading.gif data-src=/imgs/wechat-pay.png alt="debuger - Wechat Pay">
<span>Wechat Pay</span></div></div></div><div class=post-copyright><img src=/imgs/cc/cc.svg width=75 height=75 align=right><ul><li class=post-copyright-title><strong>Post Title:</strong>
Pebble 源码剖析-写入流程</li><li class=post-copyright-author><strong>Written By:</strong>
ZhenyuXie</li><li class=post-copyright-link><strong>Post Link:</strong>
<a id=post-cr-link href=/2022/01/24/pebble-write/ title="Pebble 源码剖析-写入流程">/2022/01/24/pebble-write/</a></li><li class=post-copyright-license><strong>Copyright Notice:</strong>
All articles in this blog are licensed under <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh>BY-NC-SA</a> unless stating additionally.</li></ul></div><div class=followme><span>Welcome to my other publishing channels</span><div class=social-list><div class=social-item><a target=_blank class=social-link href=/images/wechat_channel.jpg><span class=icon><i class="fab fa-weixin"></i></span>
<span class=label>WeChat</span></a></div><div class=social-item><a target=_blank class=social-link href=/atom.xml><span class=icon><i class="fa fa-rss"></i></span>
<span class=label>RSS</span></a></div></div></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/2022/01/27/compaction-size-tired/ rel=next title="Compaction 策略 - Size-Tiered"><i class="fa fa-chevron-left"></i> Compaction 策略 - Size-Tiered</a></div><div class="post-nav-prev post-nav-item"><a href=/2022/01/20/pebble-intr/ rel=prev title=初识Pebble>初识Pebble
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div id=comments class=post-comments><div class=comment-head><div class=comment-headline><i class="fas fa-comments fa-fw"></i>
<span>Comments</span></div></div><div class=comment-wrap><div><div class=comment-loading><i class="fa fa-sync fa-spin"></i></div><div class=giscus-container></div></div></div></div></div></main><footer class=footer><div class=footer-inner><div id=gtranslate class=google-translate><i class="fa fa-language"></i><div id=google_translate_element></div></div><div class=copyright>&copy;
<span itemprop=copyrightYear>2010 - 2023</span>
<span class=with-love><i class="fa fa-heart"></i></span>
<span class=author itemprop=copyrightHolder>debuger</span></div><div class=powered-by>Power by <a href=https://gohugo.io title=0.109.0 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.4.0 target=_blank>Hugo NexT.Gemini</a></div></div></footer><script type=text/javascript src=https://cdn.staticfile.org/animejs/3.2.1/anime.min.js defer></script>
<script type=text/javascript src=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.js defer></script>
<script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"busuanzi":{"pageview":true},"copybtn":true,"darkmode":false,"giscus":{"cfg":{"category":"Comments","categoryid":null,"emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"zhenyuxie/zhenyuxie.github.io","repoid":null,"theme":"preferred_color_scheme"},"js":"https://giscus.app/client.js"},"hostname":"/","i18n":{"ds_day":" Day Ago","ds_days":" Day ","ds_hour":" Hour Ago","ds_hours":" Hour ","ds_just":"Just","ds_min":" Min Ago","ds_mins":" Min","ds_month":" Month Ago","ds_years":" Year ","empty":"We didn't find any results for the search: ${query}","hits":"","hits_time":"${hits} results found in ${time} ms","placeholder":"Searching..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":230},"statis":{"enable":true,"plugin":"busuanzi"},"vendor":{"plugins":"qiniu","router":"https://cdn.staticfile.org"},"version":"4.4.0","waline":{"cfg":{"comment":true,"emoji":false,"imguploader":false,"pageview":true,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"serverurl":"https://walinejs.comment.lithub.cc","sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"waline","file":"dist/waline.css","name":"@waline/client","version":"2.13.0"},"js":{"alias":"waline","file":"dist/waline.js","name":"@waline/client","version":"2.13.0"}}}</script><script type=text/javascript src=/js/main.min.37028fbafbd97fd89808b4c7b5a3a81f01ed0ab24001d273d774f9546a0e9170.js defer></script></body></html>