<!doctype html><html lang=zh-cn data-theme=light><head><meta charset=utf-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: light)"><meta name=generator content="Hugo 0.109.0"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_16x16_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_32_32_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="Pebble 源码剖析-写入流程(续)"><meta itemprop=description content="Pebble 是 Cockroach  参考 RocksDB 并用 Go 语言开发的高性能 KV 存储引擎."><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="/imgs/hugo_next_avatar.png"><meta itemprop=keywords content="Pebble"><meta property="og:type" content="article"><meta property="og:title" content="Pebble 源码剖析-写入流程(续)"><meta property="og:description" content="Pebble 是 Cockroach  参考 RocksDB 并用 Go 语言开发的高性能 KV 存储引擎."><meta property="og:image" content="/imgs/hugo_next_avatar.png"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="/2022/01/24/pebble-write-s/"><meta property="og:site_name" content="debuger"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="debuger"><meta property="article:published_time" content="2022-02-16 23:26:00 +0000 UTC"><meta property="article:modified_time" content="2022-02-16 23:26:00 +0000 UTC"><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/font-awesome/6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.css><link rel=stylesheet href=/css/main.min.42b65f4b5d8fdb26467483a54df0d4f1570d2f58db628dde5a9075d4ba6c423c.css><style type=text/css>.post-footer,.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":true,"isHome":false,"isPage":true,"math":{"js":{"file":"es5/tex-mml-chtml.js","name":"mathjax","version":"3.2.0"},"render":"mathjax"},"path":"pebble-write-s","permalink":"/2022/01/24/pebble-write-s/","title":"Pebble 源码剖析-写入流程(续)","waline":{"js":[{"alias":"waline","alias_name":"@waline/client","file":"dist/pageview.js","name":"pageview","version":"2.13.0"},{"alias":"waline","alias_name":"@waline/client","file":"dist/comment.js","name":"comment","version":"2.13.0"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>Pebble 源码剖析-写入流程(续) - debuger</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label="Toggle navigation bar" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>debuger</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>大道至简</p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about.html class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>技术博客
<span class=badge>18</span></a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>Search</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=Searching... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>TOC</li><li class=sidebar-nav-overview>Overview</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><ul><li><a href=#large-batch>Large Batch</a></li><li><a href=#思考>思考</a></li><li><a href=#总结>总结</a></li></ul></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=debuger src=/imgs/img-lazy-loading.gif data-src=/imgs/hugo_next_avatar.png><p class=site-author-name itemprop=name>debuger</p><div class=site-description itemprop=description>Simple is the best.</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>18</span>
<span class=site-state-item-name>Posts</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>13</span>
<span class=site-state-item-name>Categories</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>19</span>
<span class=site-state-item-name>Tags</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://www.zhihu.com/people/xzy-51-38 title="知乎 → https://www.zhihu.com/people/xzy-51-38" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-book fa-fw hvr-icon"></i>知乎</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title="Creative Commons"><img src=/imgs/img-lazy-loading.gif data-src=/imgs/cc/big/by_nc_sa.svg alt="Creative Commons"></a></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>Web Status</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>Running:</div><div class=item-count id=runTimes data-publishdate=2022-01-20T22:00:00+00:00></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>Visitors:</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>Views:</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>Words:</div><div class=item-count id=wordsCount data-count=50640></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>ReadTime:</div><div class=item-count id=readTimes data-times=112></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>Last Update:</div><div class=item-count id=last-push-date data-lastpushdate=2023-09-05T23:00:00+00:00></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-comments class="button goto-comments" title="Go to Comment"><i class="fas fa-comments"></i></div><div id=goto-gtranslate class=button title="Multilingual translation"><i class="fas fa-globe"></i></div><div id=toggle-theme class=button title="Change Theme"><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title="Back to Top"><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a>
<a href=https://github.com/debuger6 rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><script type=text/javascript src=//sidecar.gitter.im/dist/sidecar.v1.js async></script>
<script type=text/javascript>((window.gitter={}).chat={}).options={room:"hugo-next/community"}</script><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=/2022/01/24/pebble-write-s/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/hugo_next_avatar.png"><meta itemprop=name content="debuger"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="debuger"><meta itemprop=description content="Simple is the best."></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="Pebble 源码剖析-写入流程(续)"><meta itemprop=description content="Pebble 是 Cockroach  参考 RocksDB 并用 Go 语言开发的高性能 KV 存储引擎."></span><header class=post-header><h1 class=post-title itemprop="name headline">Pebble 源码剖析-写入流程(续)</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i></span>
<span class=post-meta-item-text>Publish on:</span>
<time title="Publish on:2022-02-16 23:26:00 +0000 UTC" itemprop="dateCreated datePublished" datetime="2022-02-16 23:26:00 +0000 UTC">2022-02-16</time></span>
<span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i></span>
<span class=post-meta-item-text>Classify at:</span>
<span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/pebble itemprop=url rel=index><span itemprop=name>pebble</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=Words><span class=post-meta-item-icon><i class="far fa-file-word"></i></span>
<span class=post-meta-item-text>Words:</span><span>2409</span></span>
<span class=post-meta-item title=Read><span class=post-meta-item-icon><i class="far fa-clock"></i></span>
<span class=post-meta-item-text>Read:&ap;</span>
<span>5min</span></span>
<span class=post-meta-item title=Views><span class=post-meta-item-icon><i class="far fa-eye"></i></span>
<span class=post-meta-item-text>Views:</span>
<span id=busuanzi_value_page_pv class=waline-pageview-count data-path=/2022/01/24/pebble-write-s/><i class="fa fa-sync fa-spin"></i></span></span>
<span class=post-meta-item title=Comments><span class=post-meta-item-icon><i class="far fa-comments"></i></span>
<span class=post-meta-item-text>Comments:</span>
<span class=waline-comment-count data-path=/2022/01/24/pebble-write-s/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>上一章，分析了 Pebble 写入的整体流程，并深入分析了 Pipeline 的三个执行阶段。但还未对 large batch 和 makeRoomForWrite 具体执行逻辑进行分析，本章将对这两点内容展开讨论。</p><h3 id=large-batch>Large Batch</h3><p>这里首先思考两个问题：为什么需要区分 large batch，为什么需要对 large batch 特殊处理？笔者最初以比较疑惑，带着疑问向社区提了
<a href=https://github.com/cockroachdb/pebble/issues/1464 title=issue rel="noopener external nofollow noreferrer" target=_blank class=exturl>issue
<i class="fa fa-external-link-alt"></i></a> ，大家可以看下官方开发人员的回答。</p><p>回顾下上一章 DB.Apply 方法部分代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span>	<span style=color:#66d9ef>if</span> int(<span style=color:#a6e22e>batch</span>.<span style=color:#a6e22e>memTableSize</span>) <span style=color:#f92672>&gt;=</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>largeBatchThreshold</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>batch</span>.<span style=color:#a6e22e>flushable</span> = <span style=color:#a6e22e>newFlushableBatch</span>(<span style=color:#a6e22e>batch</span>, <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>opts</span>.<span style=color:#a6e22e>Comparer</span>)
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><p>这里会判断 batch 的大小，如果其超过设定的阈值，则将该 batch 当做 large batch 处理。这里会调用 newFlushableBatch 方法，根据 batch 生成一个 flushable（可以理解成 immutable memtable）。下面看一下 <strong>newFlushableBatch</strong> 具体的逻辑：</p><blockquote><p>该函数代码比较冗长，这里省略部分分支逻辑，保留主要逻辑</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>newFlushableBatch</span>(<span style=color:#a6e22e>batch</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Batch</span>, <span style=color:#a6e22e>comparer</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Comparer</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>flushableBatch</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>flushableBatch</span>{
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>data</span>:      <span style=color:#a6e22e>batch</span>.<span style=color:#a6e22e>data</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>cmp</span>:       <span style=color:#a6e22e>comparer</span>.<span style=color:#a6e22e>Compare</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>formatKey</span>: <span style=color:#a6e22e>comparer</span>.<span style=color:#a6e22e>FormatKey</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>offsets</span>:   make([]<span style=color:#a6e22e>flushableBatchEntry</span>, <span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>batch</span>.<span style=color:#a6e22e>Count</span>()),
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>data</span>) &gt; <span style=color:#a6e22e>batchHeaderLen</span> {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Non-empty batch.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>index</span> <span style=color:#66d9ef>uint32</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 迭代 batch
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>iter</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>BatchReader</span>(<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>data</span>[<span style=color:#a6e22e>batchHeaderLen</span>:]); len(<span style=color:#a6e22e>iter</span>) &gt; <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>index</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>offset</span> <span style=color:#f92672>:=</span> uintptr(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>iter</span>[<span style=color:#ae81ff>0</span>])) <span style=color:#f92672>-</span> uintptr(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>data</span>[<span style=color:#ae81ff>0</span>]))
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 解析当前 batch record
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#a6e22e>kind</span>, <span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>iter</span>.<span style=color:#a6e22e>Next</span>()
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>ok</span> {
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>entry</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>flushableBatchEntry</span>{
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>offset</span>: uint32(<span style=color:#a6e22e>offset</span>),
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>index</span>:  uint32(<span style=color:#a6e22e>index</span>),
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>      
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>entry</span>.<span style=color:#a6e22e>keyStart</span> = uint32(uintptr(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>key</span>[<span style=color:#ae81ff>0</span>])) <span style=color:#f92672>-</span>
</span></span><span style=display:flex><span>				uintptr(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>data</span>[<span style=color:#ae81ff>0</span>])))
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>entry</span>.<span style=color:#a6e22e>keyEnd</span> = <span style=color:#a6e22e>entry</span>.<span style=color:#a6e22e>keyStart</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>keySize</span>
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>offsets</span> = append(<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>offsets</span>, <span style=color:#a6e22e>entry</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>pointOffsets</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>offsets</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>sort</span>.<span style=color:#a6e22e>Sort</span>(<span style=color:#a6e22e>b</span>)
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>b</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>首先，初始 flushableBatch **b **，<strong>b</strong> 中包含了原始 batch 的数据；然后迭代 batch，解析 batch 的每个 record 生成 flushableBatchEntry，entry 主要包含 record 在 batch 中的偏移 <em>offset</em>，record 是 batch 索引号 <em>index</em>（用于计算当前 record 的 seqNum），record 的原始 key 在 batch 中的起始偏移和终止位置。可以看到 entry 主要记录的是 record 相关的位置和偏移信息，根据这些信息可以得到 record 中的 key 和 value。将 entry 加入到 <strong>b</strong> 的 offsets 中，迭代完毕后，<strong>b</strong> 便拥有了原始 batch 中所有 record 的位置和偏移信息。</p><p>最后对 <strong>b</strong> 进行排序，排序规则参考如下函数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>flushableBatch</span>) <span style=color:#a6e22e>Less</span>(<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ei</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>offsets</span>[<span style=color:#a6e22e>i</span>]
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ej</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>offsets</span>[<span style=color:#a6e22e>j</span>]
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ki</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>data</span>[<span style=color:#a6e22e>ei</span>.<span style=color:#a6e22e>keyStart</span>:<span style=color:#a6e22e>ei</span>.<span style=color:#a6e22e>keyEnd</span>]
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>kj</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>data</span>[<span style=color:#a6e22e>ej</span>.<span style=color:#a6e22e>keyStart</span>:<span style=color:#a6e22e>ej</span>.<span style=color:#a6e22e>keyEnd</span>]
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>cmp</span>(<span style=color:#a6e22e>ki</span>, <span style=color:#a6e22e>kj</span>); {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>c</span> &lt; <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>c</span> &gt; <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>default</span>:
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>ei</span>.<span style=color:#a6e22e>offset</span> &gt; <span style=color:#a6e22e>ej</span>.<span style=color:#a6e22e>offset</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可以看到 flushableBatch 的排序规则：比较 entry 间 key 的大小，比较函数默认为 bytes.Compare，如果 key 相同则偏移位置大的 key 排前面（偏移越大说明 key 是后写入，代表值越新）。</p><p>好的，到这里 flushableBatch 便准备完毕了，并会赋值给 batch 的 flushable。再回顾 DB.commitWrite，上一章把方法中 large batch 相关的逻辑省略了，如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span>	<span style=color:#a6e22e>repr</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Repr</span>()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>flushable</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>flushable</span>.<span style=color:#a6e22e>setSeqNum</span>(<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>SeqNum</span>())
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>opts</span>.<span style=color:#a6e22e>DisableWAL</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>err</span> <span style=color:#66d9ef>error</span>
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>size</span>, <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>SyncRecord</span>(<span style=color:#a6e22e>repr</span>, <span style=color:#a6e22e>syncWG</span>, <span style=color:#a6e22e>syncErr</span>)
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>				panic(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><p>接着之前的逻辑，这里 batch 的 flushable 不为空，如果启用了 wal，这些会先写 wal，而后再调用 makeRoomForWrite。这里和普通 batch 的处理顺序相反，后面会做解释。这里先看 <strong>makeRoomForWrite</strong>，该方法主要的逻辑有如下几点：</p><ul><li>当前 memtable 空间足够，直接写入</li><li>当前 memtable 空间不够，将当前 memtable 切换为 immutable memtable，然后将当前 memtable 刷盘</li><li>batch 为空或者为 large batch 则直接切换当前 memtable（注：这两种视为非常规 batch）</li><li>如果切换 memtable 则同时会生成新的 log 文件</li></ul><p>上述为 makeRoomForWrite 的主要逻辑，还要一些分支逻辑需要结合代码来看看（log 文件相关的代码省略）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>d</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>DB</span>) <span style=color:#a6e22e>makeRoomForWrite</span>(<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Batch</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>force</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>flushable</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>stalled</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 检查当前 memtable 是否正在切换中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>mem</span>.<span style=color:#a6e22e>switching</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>mem</span>.<span style=color:#a6e22e>cond</span>.<span style=color:#a6e22e>Wait</span>()
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#75715e>// batch 为正常小数据量时，进入 prepare
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>flushable</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>mem</span>.<span style=color:#a6e22e>mutable</span>.<span style=color:#a6e22e>prepare</span>(<span style=color:#a6e22e>b</span>)
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>arenaskl</span>.<span style=color:#a6e22e>ErrArenaFull</span> {
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>stalled</span> {
</span></span><span style=display:flex><span>					<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>opts</span>.<span style=color:#a6e22e>EventListener</span>.<span style=color:#a6e22e>WriteStallEnd</span>()
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#75715e>// force || err == ErrArenaFull, so we need to rotate the current memtable.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		{
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>size</span> <span style=color:#66d9ef>uint64</span>
</span></span><span style=display:flex><span>			<span style=color:#75715e>// 计算所有 memtable 大小
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>mem</span>.<span style=color:#a6e22e>queue</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>size</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>mem</span>.<span style=color:#a6e22e>queue</span>[<span style=color:#a6e22e>i</span>].<span style=color:#a6e22e>totalBytes</span>()
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#75715e>// 总大小超过阈值，需要阻塞写，等待 compact 完成
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>size</span> <span style=color:#f92672>&gt;=</span> uint64(<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>opts</span>.<span style=color:#a6e22e>MemTableStopWritesThreshold</span>)<span style=color:#f92672>*</span>uint64(<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>opts</span>.<span style=color:#a6e22e>MemTableSize</span>) {
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>stalled</span> {
</span></span><span style=display:flex><span>					<span style=color:#a6e22e>stalled</span> = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>					<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>opts</span>.<span style=color:#a6e22e>EventListener</span>.<span style=color:#a6e22e>WriteStallBegin</span>(<span style=color:#a6e22e>WriteStallBeginInfo</span>{
</span></span><span style=display:flex><span>						<span style=color:#a6e22e>Reason</span>: <span style=color:#e6db74>&#34;memtable count limit reached&#34;</span>,
</span></span><span style=display:flex><span>					})
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>compact</span>.<span style=color:#a6e22e>cond</span>.<span style=color:#a6e22e>Wait</span>()
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>l0ReadAmp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>versions</span>.<span style=color:#a6e22e>currentVersion</span>().<span style=color:#a6e22e>L0Sublevels</span>.<span style=color:#a6e22e>ReadAmplification</span>()
</span></span><span style=display:flex><span>		<span style=color:#75715e>// l0 读放大超过阈值需要阻塞等待
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>l0ReadAmp</span> <span style=color:#f92672>&gt;=</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>opts</span>.<span style=color:#a6e22e>L0StopWritesThreshold</span> {
</span></span><span style=display:flex><span>			<span style=color:#75715e>// There are too many level-0 files, so we wait.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>stalled</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>stalled</span> = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>opts</span>.<span style=color:#a6e22e>EventListener</span>.<span style=color:#a6e22e>WriteStallBegin</span>(<span style=color:#a6e22e>WriteStallBeginInfo</span>{
</span></span><span style=display:flex><span>					<span style=color:#a6e22e>Reason</span>: <span style=color:#e6db74>&#34;L0 file count limit exceeded&#34;</span>,
</span></span><span style=display:flex><span>				})
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>compact</span>.<span style=color:#a6e22e>cond</span>.<span style=color:#a6e22e>Wait</span>()
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>flushable</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>entry</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>newFlushableEntry</span>(<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>flushable</span>, <span style=color:#a6e22e>imm</span>.<span style=color:#a6e22e>logNum</span>, <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>SeqNum</span>())
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>entry</span>.<span style=color:#a6e22e>releaseMemAccounting</span> = <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>opts</span>.<span style=color:#a6e22e>Cache</span>.<span style=color:#a6e22e>Reserve</span>(int(<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>flushable</span>.<span style=color:#a6e22e>totalBytes</span>()))
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>mem</span>.<span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>mem</span>.<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>entry</span>)
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>imm</span>.<span style=color:#a6e22e>logNum</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>logSeqNum</span> <span style=color:#66d9ef>uint64</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>logSeqNum</span> = <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>SeqNum</span>()
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>flushable</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>logSeqNum</span> <span style=color:#f92672>+=</span> uint64(<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Count</span>())
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>logSeqNum</span> = <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>LoadUint64</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>versions</span>.<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>logSeqNum</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>entry</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>flushableEntry</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>mem</span>.<span style=color:#a6e22e>mutable</span>, <span style=color:#a6e22e>entry</span> = <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>newMemTable</span>(<span style=color:#a6e22e>newLogNum</span>, <span style=color:#a6e22e>logSeqNum</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>mem</span>.<span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>mem</span>.<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>entry</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>updateReadStateLocked</span>(<span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>immMem</span>.<span style=color:#a6e22e>writerUnref</span>() {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>maybeScheduleFlush</span>()
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>force</span> = <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可以看到，这里有两种情况会强制切换 memtable，一种是 batch 为空，代表手动 flush，另一种是 batch 为 large batch。下面循环中，首先检查当前 memtable 是否正在切换中，如果是则等待当前 memtable 切换完毕；</p><p>随后判断当前 batch 是否为常规 batch，如果为常规 batch ，则调用 memtable 的 prepare 函数判断当前 batch 空间是否足够，如果足够则直接返回，否则返回 ErrArenaFull，代表空间已满；</p><p>下面进入切换 memtable 的逻辑，到这里可以看出，有三种情况会切换 memtable：1. 手动 flush，2. Large batch 3. 当前 memtable 已满；接下来会计算当前内存所有 memtable 的空间大小，如果总大小超过停写阈值，则会阻塞写，等待 compact 完成；再接下来会判断 L0 的读放大是否超过阈值，如果超过则阻塞写，等待 compact 完成；</p><p>如果是 large batch，则会生成 flushableEntry，然后添加到 immutable queue 中；最后会将当前 memtable 切换为 immutable 并加入到 queue 中。最后将 immutable 解引用，并调用 maybeScheduleFlush 触发写入操作。</p><h3 id=思考>思考</h3><p>这里思考几个问题：</p><ol><li>为什么需要设计 large batch</li><li>large batch 的日志写入为什么在 makeRoomForWrite 之前（和普通 batch 对比）</li><li>large batch 为什么会触发 memtable 切换</li></ol><p>这几个问题的解答可以参考笔者向官方提的
<a href=https://github.com/cockroachdb/pebble/issues/1464 title=issue rel="noopener external nofollow noreferrer" target=_blank class=exturl>issue
<i class="fa fa-external-link-alt"></i></a> 以及
<a href=https://github.com/cockroachdb/pebble/blob/master/docs/rocksdb.md#large-batches title=官方文档 rel="noopener external nofollow noreferrer" target=_blank class=exturl>官方文档
<i class="fa fa-external-link-alt"></i>
</a>对 large batch 来源说明。这里笔者参考官方的回答及自己的理解，对上述问题进行解答下。</p><p>第一个问题，根据官方描述，pebble 的 memtable 实际上是一个预分配的固定内存大小的 skiplist，因此当 batch 超过 memtable 内存大小时，无法扩容，只能将 large batch 转变为 flushable 来处理，这样间接解决 memtable 内存无法容纳 large batch 的问题。再一个原因是，如果当前 large batch 过大即使未超过 memtable 内存，将 large batch 写入 memtable，那么很快就会导致 memtable full，触发 flush，既然 large batch 很快便会触发 flush，那么不如直接将其转变为 flushable，这样也避免了 large batch 到 memtable 的拷贝开销。</p><p>第二个问题，large batch 转变为 flushable 后，在 makeRoomForWrite 中会将其当做 immutable 加入到 immutable queue 中，相当于数据写入内存中，同时可能触发 flush，因此，在数据写入内存前应该先写 log，也就是日志的写入需要在 makeRoomForWrite 前。这个逻辑和普通的 batch 处理不同，可以参考上一章。</p><p>第三个问题，既然 large batch 并未写入到当前的 memtable 中，为什么也会将当前的 memtable 切换为 immutable？这个问题要和第二个问题结合起来看，从第二个问题可以知道，large batch 和当前 memtable 其实是共用的同一个 wal，在 makeRoomForWrite 中可能会触发 large batch 的 flushable 刷盘，刷盘后其对应的 wal 理应被删除以避免日志 replay 的开销，因此 memtable 也会被牵连一起刷盘。</p><h3 id=总结>总结</h3><p>本章主要讲解了写入流程中 pebble 对 large batch 的特殊处理方式，同时分析了 makeRoomForWrite 的处理逻辑。最后分析了为什么会产生 large batch 及针对 large batch 特殊处理的原因。</p></div><footer class=post-footer><div class=post-tags><a href=/tags/pebble>Pebble</a></div><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=post-copyright><img src=/imgs/cc/cc.svg width=75 height=75 align=right><ul><li class=post-copyright-title><strong>Post Title:</strong>
Pebble 源码剖析-写入流程(续)</li><li class=post-copyright-author><strong>Written By:</strong>
debuger</li><li class=post-copyright-link><strong>Post Link:</strong>
<a id=post-cr-link href=/2022/01/24/pebble-write-s/ title="Pebble 源码剖析-写入流程(续)">/2022/01/24/pebble-write-s/</a></li><li class=post-copyright-license><strong>Copyright Notice:</strong>
All articles in this blog are licensed under <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh>BY-NC-SA</a> unless stating additionally.</li></ul></div><div class=followme><span>Welcome to my other publishing channels</span><div class=social-list><div class=social-item><a target=_blank class=social-link href=/images/wechat_channel.jpg><span class=icon><i class="fab fa-weixin"></i></span>
<span class=label>WeChat</span></a></div><div class=social-item><a target=_blank class=social-link href=/atom.xml><span class=icon><i class="fa fa-rss"></i></span>
<span class=label>RSS</span></a></div></div></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/2022/02/26/pebble-skiplist/ rel=next title="Pebble 源码剖析 - Skiplist"><i class="fa fa-chevron-left"></i> Pebble 源码剖析 - Skiplist</a></div><div class="post-nav-prev post-nav-item"><a href=/2022/01/30/compaction-leveled/ rel=prev title="Compaction 策略 - Leveled">Compaction 策略 - Leveled
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div id=comments class=post-comments><div class=comment-head><div class=comment-headline><i class="fas fa-comments fa-fw"></i>
<span>Comments</span></div></div><div class=comment-wrap><div><div class=comment-loading><i class="fa fa-sync fa-spin"></i></div><div class=giscus-container></div></div></div></div></div></main><footer class=footer><div class=footer-inner><div id=gtranslate class=google-translate><i class="fa fa-language"></i><div id=google_translate_element></div></div><div class=copyright>&copy;
<span itemprop=copyrightYear>2010 - 2023</span>
<span class=with-love><i class="fa fa-heart"></i></span>
<span class=author itemprop=copyrightHolder>debuger</span></div><div class=powered-by>Power by <a href=https://gohugo.io title=0.109.0 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.4.0 target=_blank>Hugo NexT.Gemini</a></div></div></footer><script type=text/javascript src=https://cdn.staticfile.org/animejs/3.2.1/anime.min.js defer></script>
<script type=text/javascript src=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.js defer></script>
<script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"busuanzi":{"pageview":true},"copybtn":true,"darkmode":false,"giscus":{"cfg":{"category":"Announcements","categoryid":"DIC_kwDOIqmyr84CTQGv","emit":false,"inputposition":"top","mapping":"title","reactions":true,"repo":"debuger6/zhenyuxie.github.io","repoid":"R_kgDOIqmyrw","theme":"preferred_color_scheme"},"js":"https://giscus.app/client.js"},"hostname":"/","i18n":{"ds_day":" Day Ago","ds_days":" Day ","ds_hour":" Hour Ago","ds_hours":" Hour ","ds_just":"Just","ds_min":" Min Ago","ds_mins":" Min","ds_month":" Month Ago","ds_years":" Year ","empty":"We didn't find any results for the search: ${query}","hits":"","hits_time":"${hits} results found in ${time} ms","placeholder":"Searching..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":230},"statis":{"enable":true,"plugin":"busuanzi"},"vendor":{"plugins":"qiniu","router":"https://cdn.staticfile.org"},"version":"4.4.0","waline":{"cfg":{"comment":true,"emoji":false,"imguploader":false,"pageview":true,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o","reaction":true,"reactiontext":["点赞","得意"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"serverurl":"https://walinejs.comment.lithub.cc","sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"waline","file":"dist/waline.css","name":"@waline/client","version":"2.13.0"},"js":{"alias":"waline","file":"dist/waline.js","name":"@waline/client","version":"2.13.0"}}}</script><script type=text/javascript src=/js/main.min.37028fbafbd97fd89808b4c7b5a3a81f01ed0ab24001d273d774f9546a0e9170.js defer></script>
<script type=text/javascript src=/js/math.min.95d37ca8344f2f635c0f13f77cc75191efb6cdf99093ed73203a86e05f995fbb.js defer></script></body></html>