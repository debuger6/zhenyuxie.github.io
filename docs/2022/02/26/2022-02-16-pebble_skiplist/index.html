<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf8" />
    <meta name="viewport" content="initial-scale=1.0, width=device-width" />
    <title>
      
        Pebble 源码剖析 - Skiplist | Debuger
      
    </title>
    <meta name="description" content="description"/>
    <meta name="keywords" content="keywords"/>
    
      <link rel="apple-touch-icon"
            sizes="180x180"
            href="/images/apple-touch-icon.png"/>
    
    
      <link rel="icon"
            type="image/png"
            sizes="32x32"
            href="/images/favicon-32x32.png"/>
    
    
      <link rel="icon"
            type="image/png"
            sizes="16x16"
            href="/images/favicon-16x16.png"/>
    
    
      <link rel="mask-icon"
            href="/images/logo.svg"
            color=""/>
    
    
    <link rel="stylesheet" type="text/css" href="/css/layout.css"/>
    
    
  <link rel="stylesheet" type="text/css" href="/css/post.css"/>
  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />

  <meta name="generator" content="Hexo 6.3.0"></head>
  <body>
    <div class="head">
      <div class="nav">
        <a href="/" class="nav-logo">
          <img alt="logo" height="60px" width="60px" src="/images/logo.svg" />
        </a>
        <input id="navBtn" type="checkbox"/>
        <div class="nav-menu">
          
            
              <a class="nav-menu-item" href="/computer">计算机技术</a>
            
              <a class="nav-menu-item" href="/science">数理科学</a>
            
              <a class="nav-menu-item" href="/life">生活</a>
            
          
        </div>
        <label class="nav-btn" for="navBtn"></label>
      </div>
    </div>
    <div class="body">
      
  <article class="post-content">
    <div class="post-inner">
      <div class="post-content__head">
        <div class="post-title">Pebble 源码剖析 - Skiplist</div>
        <div class="post-info">
          
  
    <a href="/tags/Pebble/" class="post-tag">#Pebble</a>
  


          <span class="post-date">2022-02-26</span>
        </div>
      </div>
      <div class="post-content__body">
        
          <div class="post-gallery">
            
          </div>
        
        <p>本章主要从源码角度来分析 Pebble 对 Skiplist（跳表）的高性能设计，对于跳表的介绍及原理可以参考<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%B7%B3%E8%A1%A8/22819833">百科</a>或网上其他文章，本文不做冗余介绍。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>容易想到，跳表和普通链表类似，由多个节点组成，不同的是，每个节点有多层，因此会有多个 next 指针指向每层的下个节点，如下图：</p>
<p><img src="/images/pebble/800px-Skip_list.svg.png" alt="800px-Skip_list.svg"></p>
<p>跳表的逻辑结构很容易理解，使用链表这种数据结构实现非常直观。但是 Pebble 从高性能的角度出发，底层存储并未使用链表，而使用的是数组，通过 CAS 无锁技术，在并发场景下具备高效的性能。下面先来看看源码中几个关键的数据结构。</p>
<h4 id="Skiplist"><a href="#Skiplist" class="headerlink" title="Skiplist"></a>Skiplist</h4><p>Skiplist 源码定义如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Skiplist <span class="keyword">struct</span> &#123;</span><br><span class="line">	arena  *Arena</span><br><span class="line">	cmp    base.Compare</span><br><span class="line">	head   *node</span><br><span class="line">	tail   *node</span><br><span class="line">	height <span class="type">uint32</span> <span class="comment">// Current height. 1 &lt;= height &lt;= maxHeight. CAS.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// If set to true by tests, then extra delays are added to make it easier to</span></span><br><span class="line">	<span class="comment">// detect unusual race conditions.</span></span><br><span class="line">	testing <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Arena <span class="keyword">struct</span> &#123;</span><br><span class="line">	n   <span class="type">uint64</span></span><br><span class="line">	buf []<span class="type">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到整个结构比较简单，arena 代表跳表数据存储的地方，是一个固定大小的 buffer；cmp 代表跳表内节点值的比较函数；head 为头节点；tail 为尾节点；height 代表跳表的高度（节点当前最大层数）；testing 为测试时候使用，可以忽略。</p>
<h4 id="node"><a href="#node" class="headerlink" title="node"></a>node</h4><p>再来看看里面核心结构 node 的定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Immutable fields, so no need to lock to access key.</span></span><br><span class="line">	keyOffset <span class="type">uint32</span></span><br><span class="line">	keySize   <span class="type">uint32</span></span><br><span class="line">	valueSize <span class="type">uint32</span></span><br><span class="line">	allocSize <span class="type">uint32</span></span><br><span class="line">	tower [maxHeight]links</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> links <span class="keyword">struct</span> &#123;</span><br><span class="line">	nextOffset <span class="type">uint32</span></span><br><span class="line">	prevOffset <span class="type">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>keyOffset 代表 key 在 arena 中的偏移，keySize 代表 key 的大小；valueSize 代表 value 的大小；allocSize 代表 node 占用的内存大小；tower 是一个数组，每个元素相当于每层的 pre-next 指针，指向各层的前一个节点和后一个节点。</p>
<p>可以看出 node 并未存储 key-value 的具体值，而是存的偏移和大小，value 的偏移并未存储，因为可以通过 keyOffset 和 keySize 间接计算出来。tower 比较形象，可以把节点看做塔一样，有多层，每层通过双向指针串联前后节点。因此 Skiplist 逻辑上是一个双向链表，Skiplist 在 Pebble 中的物理结构如下图：</p>
<p><img src="/images/pebble/skiplist_arena.png" alt="image-20220215232733854"></p>
<blockquote>
<p>tower 指向的 node 个数有多个，图上只画了一对 link 表示节点在某层的前后节点偏移。</p>
</blockquote>
<h3 id="方法实现"><a href="#方法实现" class="headerlink" title="方法实现"></a>方法实现</h3><p>了解 Skiplist 的数据结构定义后，接下来，看看如果操作 Skiplist，即 Skiplist 的相关方法实现。</p>
<h4 id="创建跳表"><a href="#创建跳表" class="headerlink" title="创建跳表"></a>创建跳表</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSkiplist</span><span class="params">(arena *Arena, cmp base.Compare)</span></span> *Skiplist &#123;</span><br><span class="line">	skl := &amp;Skiplist&#123;&#125;</span><br><span class="line">	skl.Reset(arena, cmp)</span><br><span class="line">	<span class="keyword">return</span> skl</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建 Skiplist 时，需要由外部传入 arena 和 cmp，Skiplist 的容量和比较函数由使用者决定。这里会调用 Reset 对 Skiplist 进行初始化操作，来看看具体实现逻辑：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> Reset(arena *Arena, cmp base.Compare) &#123;</span><br><span class="line">	<span class="comment">// Allocate head and tail nodes.</span></span><br><span class="line">	head, err := newRawNode(arena, maxHeight, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;arenaSize is not large enough to hold the head node&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	head.keyOffset = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	tail, err := newRawNode(arena, maxHeight, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;arenaSize is not large enough to hold the tail node&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	tail.keyOffset = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Link all head/tail levels together.</span></span><br><span class="line">	headOffset := arena.getPointerOffset(unsafe.Pointer(head))</span><br><span class="line">	tailOffset := arena.getPointerOffset(unsafe.Pointer(tail))</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; maxHeight; i++ &#123;</span><br><span class="line">		head.tower[i].nextOffset = tailOffset</span><br><span class="line">		tail.tower[i].prevOffset = headOffset</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	*s = Skiplist&#123;</span><br><span class="line">		arena:  arena,</span><br><span class="line">		cmp:    cmp,</span><br><span class="line">		head:   head,</span><br><span class="line">		tail:   tail,</span><br><span class="line">		height: <span class="number">1</span>,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然是初始化，那肯定是对 Skiplist 里面的成员变量进行初始化操作，arena 和 cmp 已经有了，很明显还需要对 head、tail、height 进行初始化赋值。首先通过 newRawNode 创建 head 节点和 tail 节点，由于 head 和 tail 不存储 key-value，因此 keyOffset 都初始化为 0，代表没有具体值；然后获取 head 和 tail 在 arena 中的偏移位置，并初始化 head.tower 的 nextOffset 和 tail.tower 的 prevOffset。</p>
<p>最后，Skiplist 中个成员变量初始化完毕，Skiplist 便算是创建成功了。接下来看看 newRawNode 的实现逻辑。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newRawNode</span><span class="params">(arena *Arena, height <span class="type">uint32</span>, keySize, valueSize <span class="type">uint32</span>)</span></span> (nd *node, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// Compute the amount of the tower that will never be used, since the height</span></span><br><span class="line">	<span class="comment">// is less than maxHeight.</span></span><br><span class="line">	unusedSize := <span class="type">uint32</span>((maxHeight - <span class="type">int</span>(height)) * linksSize)</span><br><span class="line">	nodeSize := <span class="type">uint32</span>(maxNodeSize) - unusedSize</span><br><span class="line"></span><br><span class="line">	nodeOffset, allocSize, err := arena.alloc(nodeSize+keySize+valueSize, align4, unusedSize)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	nd = (*node)(arena.getPointer(nodeOffset))</span><br><span class="line">	nd.keyOffset = nodeOffset + nodeSize</span><br><span class="line">	nd.keySize = keySize</span><br><span class="line">	nd.valueSize = valueSize</span><br><span class="line">	nd.allocSize = allocSize</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>newRawNode 会在 arena 中分配 node 所需内存大小，然后将成员变量的值存入 arena 中。由于节点的高度，即 tower 的层数小于等于 maxHeight，height 到 maxHeight 之间的 links 并不会使用，这里要计算出未使用的大小，然后再用节点最大大小减去未使用大小得到节点实际大小；</p>
<p>知道节点的大小后，便可以在 arena 中分配相应大小的内存空间，最后对 node 成员变量初始化，初始化的值则保存在 arena 中。</p>
<blockquote>
<p>newRawNode 中分配 node 的内存时，采用 4 字节对齐，原因是 node 的每个变量都是 uint32（tower 元素中的成员变量也是），因此按 4 字节对齐时，cpu 访问内存获取变量值时更加高效，提升访存性能。字节对齐的好处可参考网上其他文章。</p>
</blockquote>
<h4 id="添加-key-value"><a href="#添加-key-value" class="headerlink" title="添加 key-value"></a>添加 key-value</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> Add(key base.InternalKey, value []<span class="type">byte</span>) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ins Inserter</span><br><span class="line">	<span class="keyword">return</span> s.addInternal(key, value, &amp;ins)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> addInternal(key base.InternalKey, value []<span class="type">byte</span>, ins *Inserter) <span class="type">error</span> &#123;</span><br><span class="line">  <span class="comment">// 找到 key 要插入的位置</span></span><br><span class="line">	<span class="keyword">if</span> s.findSplice(key, ins) &#123;</span><br><span class="line">		<span class="keyword">return</span> ErrRecordExists</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	nd, height, err := s.newNode(key, value)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// node 在 arena 中的偏移</span></span><br><span class="line">	ndOffset := s.arena.getPointerOffset(unsafe.Pointer(nd))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> found <span class="type">bool</span></span><br><span class="line">	<span class="keyword">var</span> invalidateSplice <span class="type">bool</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(height); i++ &#123;</span><br><span class="line">		prev := ins.spl[i].prev</span><br><span class="line">		next := ins.spl[i].next</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> prev == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> next != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="built_in">panic</span>(<span class="string">&quot;next is expected to be nil, since prev is nil&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			prev = s.head</span><br><span class="line">			next = s.tail</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="comment">// 获取 prev 和 next 的偏移</span></span><br><span class="line">			prevOffset := s.arena.getPointerOffset(unsafe.Pointer(prev))</span><br><span class="line">			nextOffset := s.arena.getPointerOffset(unsafe.Pointer(next))</span><br><span class="line">			nd.tower[i].init(prevOffset, nextOffset)</span><br><span class="line"></span><br><span class="line">			nextPrevOffset := next.prevOffset(i)</span><br><span class="line">      <span class="comment">// next 的 prevOffset 不指向 prevOffset</span></span><br><span class="line">			<span class="keyword">if</span> nextPrevOffset != prevOffset &#123;</span><br><span class="line">				prevNextOffset := prev.nextOffset(i)</span><br><span class="line">        <span class="comment">// prev 的 nextOffset 指向 next，说明 next 的 prevOffset 还没来得及修改</span></span><br><span class="line">				<span class="keyword">if</span> prevNextOffset == nextOffset &#123;</span><br><span class="line">					next.casPrevOffset(i, nextPrevOffset, prevOffset)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// cas 修改 prev 的 nextOffset</span></span><br><span class="line">			<span class="keyword">if</span> prev.casNextOffset(i, nextOffset, ndOffset) &#123;</span><br><span class="line">        <span class="comment">// cas 修改 next 的 prevOffset</span></span><br><span class="line">				next.casPrevOffset(i, prevOffset, ndOffset)</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">      <span class="comment">// cas 失败，说明其他线程成功插入节点，需要重新计算 key 插入的位置</span></span><br><span class="line">			prev, next, found = s.findSpliceForLevel(key, i, prev)</span><br><span class="line">			<span class="keyword">if</span> found &#123;</span><br><span class="line">				<span class="keyword">if</span> i != <span class="number">0</span> &#123;</span><br><span class="line">					<span class="built_in">panic</span>(<span class="string">&quot;how can another thread have inserted a node at a non-base level?&quot;</span>)</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">return</span> ErrRecordExists</span><br><span class="line">			&#125;</span><br><span class="line">			invalidateSplice = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> invalidateSplice &#123;</span><br><span class="line">		ins.height = <span class="number">0</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="type">uint32</span>(<span class="number">0</span>); i &lt; height; i++ &#123;</span><br><span class="line">			ins.spl[i].prev = nd</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们主要关注 addInternal，该方法利用循环+CAS，在并发场景下可以高效地插入节点。首先通过 findSplice 方法找到要插入的位置，位置保存在 ins 的 spl 中，该变量存储了每层的前后节点。找到位置后，创建节点并保存 key-value 值，然后再 for 循环中遍历每层的 prev 和 next，将节点插入 pre 和 next 之间，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+----------------+     +------------+     +----------------+</span><br><span class="line">|      prev      |     |     nd     |     |      next      |</span><br><span class="line">| prevNextOffset |----&gt;|            |     |                |</span><br><span class="line">|                |&lt;----| prevOffset |     |                |</span><br><span class="line">|                |     | nextOffset |----&gt;|                |</span><br><span class="line">|                |     |            |&lt;----| nextPrevOffset |</span><br><span class="line">+----------------+     +------------+     +----------------+</span><br></pre></td></tr></table></figure>

<p>插入节点时，首先将 nd 的 prevOffset 和 nextOffset 指向 prev 和 next；然后通过 for+cas 修改 prev 的 nextOffset 再修改 next 的 prevOffset，如果修改成功，退出内存循环，继续处理下一层，否则重新计算 node 在当前层的插入位置，继续重试。</p>
<blockquote>
<p>注意，这里在更新 prev 的 nextOffset 和 next 的 prevOffset 前会先修正 next 的当前 prevOffset，因为可能存在另一个线程正在插入的节点是 prev，而 prev 的 nextOffset 已经指向了 next，但是 next 的 prevOffset 还未来得及指向 prev。为了保证 cas 正确性，需要帮助另一线程将 next 的 prevOffset 指向 prev。</p>
</blockquote>
<h4 id="查找-key"><a href="#查找-key" class="headerlink" title="查找 key"></a>查找 key</h4><p>Skiplist 的查找及遍历都是通过迭代器 Iterator 实现的，这里只列出最基础的查找方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *Iterator)</span></span> seekForBaseSplice(key []<span class="type">byte</span>) (prev, next *node, found <span class="type">bool</span>) &#123;</span><br><span class="line">	ikey := base.MakeSearchKey(key)</span><br><span class="line">	level := <span class="type">int</span>(it.list.Height() - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	prev = it.list.head</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		prev, next, found = it.list.findSpliceForLevel(ikey, level, prev)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> found &#123;</span><br><span class="line">			<span class="keyword">if</span> level != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// next is pointing at the target node, but we need to find previous on</span></span><br><span class="line">				<span class="comment">// the bottom level.</span></span><br><span class="line">				prev = it.list.getPrev(next, <span class="number">0</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> level == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		level--</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法逻辑非常简单，初始查找节点为 head，然后从最高层开始查找，如果找到目标节点（注：next 才是目标节点），则将 next 0 层的前一个节点赋给 prev（必须最底层才能代表真正的前节点）；如果没有找到，则继续根据 prev 节点查找下一层，直到 0 层如果还未找到，说明目标值不存在。</p>
<p>我们继续看下 findSpliceForLevel 的逻辑：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> findSpliceForLevel(</span><br><span class="line">	key base.InternalKey, level <span class="type">int</span>, start *node,</span><br><span class="line">) (prev, next *node, found <span class="type">bool</span>) &#123;</span><br><span class="line">	prev = start</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// Assume prev.key &lt; key.</span></span><br><span class="line">		next = s.getNext(prev, level)</span><br><span class="line">		<span class="keyword">if</span> next == s.tail &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		offset, size := next.keyOffset, next.keySize</span><br><span class="line">		nextKey := s.arena.buf[offset : offset+size]</span><br><span class="line">		n := <span class="type">int32</span>(size) - <span class="number">8</span></span><br><span class="line">		cmp := s.cmp(key.UserKey, nextKey[:n])</span><br><span class="line">		<span class="keyword">if</span> cmp &lt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// We are done for this level, since prev.key &lt; key &lt; next.key.</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> cmp == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// User-key equality.</span></span><br><span class="line">			<span class="keyword">var</span> nextTrailer <span class="type">uint64</span></span><br><span class="line">			<span class="keyword">if</span> n &gt;= <span class="number">0</span> &#123;</span><br><span class="line">				nextTrailer = binary.LittleEndian.Uint64(nextKey[n:])</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				nextTrailer = <span class="type">uint64</span>(base.InternalKeyKindInvalid)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> key.Trailer == nextTrailer &#123;</span><br><span class="line">				<span class="comment">// Internal key equality.</span></span><br><span class="line">				found = <span class="literal">true</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> key.Trailer &gt; nextTrailer &#123;</span><br><span class="line">				<span class="comment">// We are done for this level, since prev.key &lt; key &lt; next.key.</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Keep moving right on this level.</span></span><br><span class="line">		prev = next</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> getNext(nd *node, h <span class="type">int</span>) *node &#123;</span><br><span class="line">	offset := atomic.LoadUint32(&amp;nd.tower[h].nextOffset)</span><br><span class="line">	<span class="keyword">return</span> (*node)(s.arena.getPointer(offset))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 start 节点开始（start.key &lt; key），获取 next 节点，getNext 内部通过原子操作获取 next 的偏移，有了偏移便可通过 arena 获取 buffer 中的 nextKey，然后比较 key 和 nextKey 的原始值（去掉 key 的后 8 位 Trailer，key 的格式参考之前的文章），如果 userKey 相等，接着比较 Trailer，如果相等，则找到目标节点；Trailer 越大，说明 key 越小（Trailer 大说明版本更新，应该排在前面），如果 key 的 Trailer 大于了 nextTrailer，那就每必要往后找了，因为后面的 Trailer 更小，反之，继续遍历下一节点。</p>
<p>到这里，暂且介绍完了 skiplist 最基本的方法 – 创建、添加、查找，根据方法的实现可以帮助大家更清晰的认识 Pebble 对 Skiplist 的实现原理及使用方式。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文主要通过对源码解析，介绍了 Pebble 如何实现一个高性能无锁的 Skiplist，并介绍了 Skiplist 的几种最基本的方法，便于加深大家对 Skiplist 的理解，也利于后续源码探索。</p>

      </div>
    </div>
  </article>
  <div class="post__foot">
    
    <div class="post-nav">
  
    <a class="post-nav-item-left" href="/2022/11/30/hello-world/">
      <div class="text-align">
        <svg t="1670570876164"
             class="icon"
             viewBox="0 0 1024 1024"
             width="16"
             height="16">
          <path d="M384 512L731.733333 202.666667c17.066667-14.933333 19.2-42.666667 4.266667-59.733334-14.933333-17.066667-42.666667-19.2-59.733333-4.266666l-384 341.333333c-10.666667 8.533333-14.933333 19.2-14.933334 32s4.266667 23.466667 14.933334 32l384 341.333333c8.533333 6.4 19.2 10.666667 27.733333 10.666667 12.8 0 23.466667-4.266667 32-14.933333 14.933333-17.066667 14.933333-44.8-4.266667-59.733334L384 512z" p-id="14596"/>
        </svg>
        <span class="text-small">上一篇</span>
      </div>
      <div>hello world</div>
    </a>
  
  <div class="vhr"></div>
  
    <a class="post-nav-item-right" href="/2022/02/16/2022-02-16-pebble_write_src_s/">
      <div class="text-align">
        <span class="text-small">下一篇</span>
        <svg t="1670570876164"
             class="icon"
             viewBox="0 0 1024 1024"
             transform="scale(-1,-1)"
             width="16"
             height="16">
          <path d="M384 512L731.733333 202.666667c17.066667-14.933333 19.2-42.666667 4.266667-59.733334-14.933333-17.066667-42.666667-19.2-59.733333-4.266666l-384 341.333333c-10.666667 8.533333-14.933333 19.2-14.933334 32s4.266667 23.466667 14.933334 32l384 341.333333c8.533333 6.4 19.2 10.666667 27.733333 10.666667 12.8 0 23.466667-4.266667 32-14.933333 14.933333-17.066667 14.933333-44.8-4.266667-59.733334L384 512z" p-id="14596"/>
        </svg>
      </div>
      Pebble 源码剖析-写入流程(续)
    </a>
  
</div>

    
    <div id="gitalk-container"></div>
  </div>

    </div>
    <div class="foot">
      <div class="foot-inner">
        <div class="foot__head">
          
            <div class="foot-line">
              <div class="matts">海</div><div class="matts">内</div><div class="matts">存</div><div class="matts">知</div><div class="matts">己</div>
            </div>
          
            <div class="foot-line">
              <div class="matts">天</div><div class="matts">涯</div><div class="matts">若</div><div class="matts">比</div><div class="matts">邻</div>
            </div>
          
        </div>
        <div class="foot__body">
          
            <div class="foot-item">
              <div class="foot-item__head">朋友</div>
              <div class="foot-item__body">
                
                  <div class="text">
                    <img alt="link"
                         height="20px"
                         width="20px"
                         src="/images/icon/icon-link.svg"/>
                    <a class="foot-link" target="_blank" rel="noopener" href="https://github.com/hooozen/hexo-theme-tranquility">Theme Tranquility</a>
                  </div>
                
                <div class="text">
                  <img alt="link"
                       height="20px"
                       width="20px"
                       src="/images/icon/icon-link+.svg"/>
                  <a class="foot-link"
                     href="mailto:xzy.debuger@gmail.com?subject=%E7%94%B3%E8%AF%B7%20Hozen.site%20%E7%9A%84%E5%8F%8B%E9%93%BE%E4%BD%8D%E7%BD%AE">
                  申请友链</a>
                </div>
              </div>
            </div>
          
          
            <div class="foot-item">
              <div class="foot-item__head">账号</div>
              <div class="foot-item__body">
                
                  <div class="text">
                    <img alt="link" height="20px" width="20px" src="/images/logo-github.svg"/>
                    <a class="foot-link" target="_blank" rel="noopener" href="https://github.com/zhenyuxie">github</a>
                  </div>
                
                  <div class="text">
                    <img alt="link" height="20px" width="20px" src="/images/logo-wx.svg"/>
                    <a class="foot-link" href="xxx">微信公众号</a>
                  </div>
                
                  <div class="text">
                    <img alt="link" height="20px" width="20px" src="/images/logo-zh.svg"/>
                    <a class="foot-link" target="_blank" rel="noopener" href="https://www.zhihu.com/people/xzy-51-38">知乎</a>
                  </div>
                
              </div>
            </div>
          
          <div class="foot-item">
            <div class="foot-item__head">联系</div>
            <div class="foot-item__body">
              <div class="text">
                <img alt="link"
                     height="20px"
                     width="20px"
                     src="/images/icon/icon-email.svg"/>
                <a class="foot-link" href="mailto:xzy.debuger@gmail.com">xzy.debuger@gmail.com</a>
              </div>
            </div>
          </div>
        </div>
        <div class="copyright">
          <a href="https://zhenyuxie.github.io">Debuger</a> &nbsp;|&nbsp;由&nbsp;<a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>&nbsp;及&nbsp;
          <svg width="20" height="20" viewBox="0 0 725 725">
            <path fill-rule="evenodd" fill="rgb(221, 221, 221)"
            d="M145.870,236.632 L396.955,103.578 L431.292,419.44 L156.600,522.53 L145.870,236.632 Z" />
            <path fill-rule="evenodd" fill="rgb(159, 159, 159)"
            d="M396.955,103.578 L564.345,234.486 L611.558,513.469 L431.292,419.44 L396.955,103.578 Z" />
            <path fill-rule="evenodd" fill="rgb(0, 0, 0)"
            d="M431.292,419.44 L611.558,513.469 L358.327,595.18 L156.600,522.53 L431.292,419.44 Z" />
          </svg>
          <a target="_blank" rel="noopener" href="https://github.com/hooozen/hexo-theme-tranquility">致远</a>&nbsp;驱动
        </div>
      </div>
    </div>
    
    
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script type="text/javascript">
  const param = JSON.parse('{"enable":true,"owner":"zhenyuxie","admin":["zhenyuxie"],"repo":"zhenyuxie/zhenyuxie.github.io","clientID":"cd5afced7353e1fbf7a6","clientSecret":"774ba7bb3da4d779a15e76442c2474e39ac01031","distractionFreeMode":false,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN"}')
  param.id = location.pathname
  const gitalk = new Gitalk(param)
  gitalk.render('gitalk-container')
</script>


  </body>
</html>
