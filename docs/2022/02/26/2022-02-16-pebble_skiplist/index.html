<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="description">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      Pebble 源码剖析 - Skiplist | Debuger
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/css/plugins/gitment.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
  
    
<script src="/js/gitment.js"></script>

  
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


  
  
    
<script src="/js/local-search.js"></script>


<meta name="generator" content="Hexo 6.3.0"></head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>
  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>Debuger</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/project/" class="item-link">Projects</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
      
        <li class="menu-item menu-item-search right-list">
    <a role="button" class="popup-trigger">
        <i class="fa fa-search fa-fw"></i>
    </a>
</li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/project/" class="menu-link">Projects</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
    
      <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
            <span class="search-icon">
                <i class="fa fa-search"></i>
            </span>
            <div class="search-input-container">
                <input autocomplete="off" autocapitalize="off"
                    placeholder="Please enter your keyword(s) to search." spellcheck="false"
                    type="search" class="search-input">
            </div>
            <span class="popup-btn-close">
                <i class="fa fa-times-circle"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>
    
  </div>
</header>

    <div id="article-banner">
  <h2>Pebble 源码剖析 - Skiplist</h2>
  <p class="post-date">2022-02-26</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><p>本章主要从源码角度来分析 Pebble 对 Skiplist（跳表）的高性能设计，对于跳表的介绍及原理可以参考<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%B7%B3%E8%A1%A8/22819833">百科</a>或网上其他文章，本文不做冗余介绍。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>容易想到，跳表和普通链表类似，由多个节点组成，不同的是，每个节点有多层，因此会有多个 next 指针指向每层的下个节点，如下图：</p>
<p><img src="/images/pebble/800px-Skip_list.svg.png" alt="800px-Skip_list.svg"></p>
<p>跳表的逻辑结构很容易理解，使用链表这种数据结构实现非常直观。但是 Pebble 从高性能的角度出发，底层存储并未使用链表，而使用的是数组，通过 CAS 无锁技术，在并发场景下具备高效的性能。下面先来看看源码中几个关键的数据结构。</p>
<h4 id="Skiplist"><a href="#Skiplist" class="headerlink" title="Skiplist"></a>Skiplist</h4><p>Skiplist 源码定义如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Skiplist <span class="keyword">struct</span> &#123;</span><br><span class="line">	arena  *Arena</span><br><span class="line">	cmp    base.Compare</span><br><span class="line">	head   *node</span><br><span class="line">	tail   *node</span><br><span class="line">	height <span class="type">uint32</span> <span class="comment">// Current height. 1 &lt;= height &lt;= maxHeight. CAS.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// If set to true by tests, then extra delays are added to make it easier to</span></span><br><span class="line">	<span class="comment">// detect unusual race conditions.</span></span><br><span class="line">	testing <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Arena <span class="keyword">struct</span> &#123;</span><br><span class="line">	n   <span class="type">uint64</span></span><br><span class="line">	buf []<span class="type">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到整个结构比较简单，arena 代表跳表数据存储的地方，是一个固定大小的 buffer；cmp 代表跳表内节点值的比较函数；head 为头节点；tail 为尾节点；height 代表跳表的高度（节点当前最大层数）；testing 为测试时候使用，可以忽略。</p>
<h4 id="node"><a href="#node" class="headerlink" title="node"></a>node</h4><p>再来看看里面核心结构 node 的定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Immutable fields, so no need to lock to access key.</span></span><br><span class="line">	keyOffset <span class="type">uint32</span></span><br><span class="line">	keySize   <span class="type">uint32</span></span><br><span class="line">	valueSize <span class="type">uint32</span></span><br><span class="line">	allocSize <span class="type">uint32</span></span><br><span class="line">	tower [maxHeight]links</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> links <span class="keyword">struct</span> &#123;</span><br><span class="line">	nextOffset <span class="type">uint32</span></span><br><span class="line">	prevOffset <span class="type">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>keyOffset 代表 key 在 arena 中的偏移，keySize 代表 key 的大小；valueSize 代表 value 的大小；allocSize 代表 node 占用的内存大小；tower 是一个数组，每个元素相当于每层的 pre-next 指针，指向各层的前一个节点和后一个节点。</p>
<p>可以看出 node 并未存储 key-value 的具体值，而是存的偏移和大小，value 的偏移并未存储，因为可以通过 keyOffset 和 keySize 间接计算出来。tower 比较形象，可以把节点看做塔一样，有多层，每层通过双向指针串联前后节点。因此 Skiplist 逻辑上是一个双向链表，Skiplist 在 Pebble 中的物理结构如下图：</p>
<p><img src="/images/pebble/skiplist_arena.png" alt="image-20220215232733854"></p>
<blockquote>
<p>tower 指向的 node 个数有多个，图上只画了一对 link 表示节点在某层的前后节点偏移。</p>
</blockquote>
<h3 id="方法实现"><a href="#方法实现" class="headerlink" title="方法实现"></a>方法实现</h3><p>了解 Skiplist 的数据结构定义后，接下来，看看如果操作 Skiplist，即 Skiplist 的相关方法实现。</p>
<h4 id="创建跳表"><a href="#创建跳表" class="headerlink" title="创建跳表"></a>创建跳表</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSkiplist</span><span class="params">(arena *Arena, cmp base.Compare)</span></span> *Skiplist &#123;</span><br><span class="line">	skl := &amp;Skiplist&#123;&#125;</span><br><span class="line">	skl.Reset(arena, cmp)</span><br><span class="line">	<span class="keyword">return</span> skl</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建 Skiplist 时，需要由外部传入 arena 和 cmp，Skiplist 的容量和比较函数由使用者决定。这里会调用 Reset 对 Skiplist 进行初始化操作，来看看具体实现逻辑：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> Reset(arena *Arena, cmp base.Compare) &#123;</span><br><span class="line">	<span class="comment">// Allocate head and tail nodes.</span></span><br><span class="line">	head, err := newRawNode(arena, maxHeight, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;arenaSize is not large enough to hold the head node&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	head.keyOffset = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	tail, err := newRawNode(arena, maxHeight, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;arenaSize is not large enough to hold the tail node&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	tail.keyOffset = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Link all head/tail levels together.</span></span><br><span class="line">	headOffset := arena.getPointerOffset(unsafe.Pointer(head))</span><br><span class="line">	tailOffset := arena.getPointerOffset(unsafe.Pointer(tail))</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; maxHeight; i++ &#123;</span><br><span class="line">		head.tower[i].nextOffset = tailOffset</span><br><span class="line">		tail.tower[i].prevOffset = headOffset</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	*s = Skiplist&#123;</span><br><span class="line">		arena:  arena,</span><br><span class="line">		cmp:    cmp,</span><br><span class="line">		head:   head,</span><br><span class="line">		tail:   tail,</span><br><span class="line">		height: <span class="number">1</span>,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然是初始化，那肯定是对 Skiplist 里面的成员变量进行初始化操作，arena 和 cmp 已经有了，很明显还需要对 head、tail、height 进行初始化赋值。首先通过 newRawNode 创建 head 节点和 tail 节点，由于 head 和 tail 不存储 key-value，因此 keyOffset 都初始化为 0，代表没有具体值；然后获取 head 和 tail 在 arena 中的偏移位置，并初始化 head.tower 的 nextOffset 和 tail.tower 的 prevOffset。</p>
<p>最后，Skiplist 中个成员变量初始化完毕，Skiplist 便算是创建成功了。接下来看看 newRawNode 的实现逻辑。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newRawNode</span><span class="params">(arena *Arena, height <span class="type">uint32</span>, keySize, valueSize <span class="type">uint32</span>)</span></span> (nd *node, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// Compute the amount of the tower that will never be used, since the height</span></span><br><span class="line">	<span class="comment">// is less than maxHeight.</span></span><br><span class="line">	unusedSize := <span class="type">uint32</span>((maxHeight - <span class="type">int</span>(height)) * linksSize)</span><br><span class="line">	nodeSize := <span class="type">uint32</span>(maxNodeSize) - unusedSize</span><br><span class="line"></span><br><span class="line">	nodeOffset, allocSize, err := arena.alloc(nodeSize+keySize+valueSize, align4, unusedSize)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	nd = (*node)(arena.getPointer(nodeOffset))</span><br><span class="line">	nd.keyOffset = nodeOffset + nodeSize</span><br><span class="line">	nd.keySize = keySize</span><br><span class="line">	nd.valueSize = valueSize</span><br><span class="line">	nd.allocSize = allocSize</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>newRawNode 会在 arena 中分配 node 所需内存大小，然后将成员变量的值存入 arena 中。由于节点的高度，即 tower 的层数小于等于 maxHeight，height 到 maxHeight 之间的 links 并不会使用，这里要计算出未使用的大小，然后再用节点最大大小减去未使用大小得到节点实际大小；</p>
<p>知道节点的大小后，便可以在 arena 中分配相应大小的内存空间，最后对 node 成员变量初始化，初始化的值则保存在 arena 中。</p>
<blockquote>
<p>newRawNode 中分配 node 的内存时，采用 4 字节对齐，原因是 node 的每个变量都是 uint32（tower 元素中的成员变量也是），因此按 4 字节对齐时，cpu 访问内存获取变量值时更加高效，提升访存性能。字节对齐的好处可参考网上其他文章。</p>
</blockquote>
<h4 id="添加-key-value"><a href="#添加-key-value" class="headerlink" title="添加 key-value"></a>添加 key-value</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> Add(key base.InternalKey, value []<span class="type">byte</span>) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ins Inserter</span><br><span class="line">	<span class="keyword">return</span> s.addInternal(key, value, &amp;ins)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> addInternal(key base.InternalKey, value []<span class="type">byte</span>, ins *Inserter) <span class="type">error</span> &#123;</span><br><span class="line">  <span class="comment">// 找到 key 要插入的位置</span></span><br><span class="line">	<span class="keyword">if</span> s.findSplice(key, ins) &#123;</span><br><span class="line">		<span class="keyword">return</span> ErrRecordExists</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	nd, height, err := s.newNode(key, value)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// node 在 arena 中的偏移</span></span><br><span class="line">	ndOffset := s.arena.getPointerOffset(unsafe.Pointer(nd))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> found <span class="type">bool</span></span><br><span class="line">	<span class="keyword">var</span> invalidateSplice <span class="type">bool</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(height); i++ &#123;</span><br><span class="line">		prev := ins.spl[i].prev</span><br><span class="line">		next := ins.spl[i].next</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> prev == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> next != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="built_in">panic</span>(<span class="string">&quot;next is expected to be nil, since prev is nil&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			prev = s.head</span><br><span class="line">			next = s.tail</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="comment">// 获取 prev 和 next 的偏移</span></span><br><span class="line">			prevOffset := s.arena.getPointerOffset(unsafe.Pointer(prev))</span><br><span class="line">			nextOffset := s.arena.getPointerOffset(unsafe.Pointer(next))</span><br><span class="line">			nd.tower[i].init(prevOffset, nextOffset)</span><br><span class="line"></span><br><span class="line">			nextPrevOffset := next.prevOffset(i)</span><br><span class="line">      <span class="comment">// next 的 prevOffset 不指向 prevOffset</span></span><br><span class="line">			<span class="keyword">if</span> nextPrevOffset != prevOffset &#123;</span><br><span class="line">				prevNextOffset := prev.nextOffset(i)</span><br><span class="line">        <span class="comment">// prev 的 nextOffset 指向 next，说明 next 的 prevOffset 还没来得及修改</span></span><br><span class="line">				<span class="keyword">if</span> prevNextOffset == nextOffset &#123;</span><br><span class="line">					next.casPrevOffset(i, nextPrevOffset, prevOffset)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// cas 修改 prev 的 nextOffset</span></span><br><span class="line">			<span class="keyword">if</span> prev.casNextOffset(i, nextOffset, ndOffset) &#123;</span><br><span class="line">        <span class="comment">// cas 修改 next 的 prevOffset</span></span><br><span class="line">				next.casPrevOffset(i, prevOffset, ndOffset)</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">      <span class="comment">// cas 失败，说明其他线程成功插入节点，需要重新计算 key 插入的位置</span></span><br><span class="line">			prev, next, found = s.findSpliceForLevel(key, i, prev)</span><br><span class="line">			<span class="keyword">if</span> found &#123;</span><br><span class="line">				<span class="keyword">if</span> i != <span class="number">0</span> &#123;</span><br><span class="line">					<span class="built_in">panic</span>(<span class="string">&quot;how can another thread have inserted a node at a non-base level?&quot;</span>)</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">return</span> ErrRecordExists</span><br><span class="line">			&#125;</span><br><span class="line">			invalidateSplice = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> invalidateSplice &#123;</span><br><span class="line">		ins.height = <span class="number">0</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="type">uint32</span>(<span class="number">0</span>); i &lt; height; i++ &#123;</span><br><span class="line">			ins.spl[i].prev = nd</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们主要关注 addInternal，该方法利用循环+CAS，在并发场景下可以高效地插入节点。首先通过 findSplice 方法找到要插入的位置，位置保存在 ins 的 spl 中，该变量存储了每层的前后节点。找到位置后，创建节点并保存 key-value 值，然后再 for 循环中遍历每层的 prev 和 next，将节点插入 pre 和 next 之间，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+----------------+     +------------+     +----------------+</span><br><span class="line">|      prev      |     |     nd     |     |      next      |</span><br><span class="line">| prevNextOffset |----&gt;|            |     |                |</span><br><span class="line">|                |&lt;----| prevOffset |     |                |</span><br><span class="line">|                |     | nextOffset |----&gt;|                |</span><br><span class="line">|                |     |            |&lt;----| nextPrevOffset |</span><br><span class="line">+----------------+     +------------+     +----------------+</span><br></pre></td></tr></table></figure>

<p>插入节点时，首先将 nd 的 prevOffset 和 nextOffset 指向 prev 和 next；然后通过 for+cas 修改 prev 的 nextOffset 再修改 next 的 prevOffset，如果修改成功，退出内存循环，继续处理下一层，否则重新计算 node 在当前层的插入位置，继续重试。</p>
<blockquote>
<p>注意，这里在更新 prev 的 nextOffset 和 next 的 prevOffset 前会先修正 next 的当前 prevOffset，因为可能存在另一个线程正在插入的节点是 prev，而 prev 的 nextOffset 已经指向了 next，但是 next 的 prevOffset 还未来得及指向 prev。为了保证 cas 正确性，需要帮助另一线程将 next 的 prevOffset 指向 prev。</p>
</blockquote>
<h4 id="查找-key"><a href="#查找-key" class="headerlink" title="查找 key"></a>查找 key</h4><p>Skiplist 的查找及遍历都是通过迭代器 Iterator 实现的，这里只列出最基础的查找方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *Iterator)</span></span> seekForBaseSplice(key []<span class="type">byte</span>) (prev, next *node, found <span class="type">bool</span>) &#123;</span><br><span class="line">	ikey := base.MakeSearchKey(key)</span><br><span class="line">	level := <span class="type">int</span>(it.list.Height() - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	prev = it.list.head</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		prev, next, found = it.list.findSpliceForLevel(ikey, level, prev)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> found &#123;</span><br><span class="line">			<span class="keyword">if</span> level != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// next is pointing at the target node, but we need to find previous on</span></span><br><span class="line">				<span class="comment">// the bottom level.</span></span><br><span class="line">				prev = it.list.getPrev(next, <span class="number">0</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> level == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		level--</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法逻辑非常简单，初始查找节点为 head，然后从最高层开始查找，如果找到目标节点（注：next 才是目标节点），则将 next 0 层的前一个节点赋给 prev（必须最底层才能代表真正的前节点）；如果没有找到，则继续根据 prev 节点查找下一层，直到 0 层如果还未找到，说明目标值不存在。</p>
<p>我们继续看下 findSpliceForLevel 的逻辑：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> findSpliceForLevel(</span><br><span class="line">	key base.InternalKey, level <span class="type">int</span>, start *node,</span><br><span class="line">) (prev, next *node, found <span class="type">bool</span>) &#123;</span><br><span class="line">	prev = start</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// Assume prev.key &lt; key.</span></span><br><span class="line">		next = s.getNext(prev, level)</span><br><span class="line">		<span class="keyword">if</span> next == s.tail &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		offset, size := next.keyOffset, next.keySize</span><br><span class="line">		nextKey := s.arena.buf[offset : offset+size]</span><br><span class="line">		n := <span class="type">int32</span>(size) - <span class="number">8</span></span><br><span class="line">		cmp := s.cmp(key.UserKey, nextKey[:n])</span><br><span class="line">		<span class="keyword">if</span> cmp &lt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// We are done for this level, since prev.key &lt; key &lt; next.key.</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> cmp == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// User-key equality.</span></span><br><span class="line">			<span class="keyword">var</span> nextTrailer <span class="type">uint64</span></span><br><span class="line">			<span class="keyword">if</span> n &gt;= <span class="number">0</span> &#123;</span><br><span class="line">				nextTrailer = binary.LittleEndian.Uint64(nextKey[n:])</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				nextTrailer = <span class="type">uint64</span>(base.InternalKeyKindInvalid)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> key.Trailer == nextTrailer &#123;</span><br><span class="line">				<span class="comment">// Internal key equality.</span></span><br><span class="line">				found = <span class="literal">true</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> key.Trailer &gt; nextTrailer &#123;</span><br><span class="line">				<span class="comment">// We are done for this level, since prev.key &lt; key &lt; next.key.</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Keep moving right on this level.</span></span><br><span class="line">		prev = next</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> getNext(nd *node, h <span class="type">int</span>) *node &#123;</span><br><span class="line">	offset := atomic.LoadUint32(&amp;nd.tower[h].nextOffset)</span><br><span class="line">	<span class="keyword">return</span> (*node)(s.arena.getPointer(offset))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 start 节点开始（start.key &lt; key），获取 next 节点，getNext 内部通过原子操作获取 next 的偏移，有了偏移便可通过 arena 获取 buffer 中的 nextKey，然后比较 key 和 nextKey 的原始值（去掉 key 的后 8 位 Trailer，key 的格式参考之前的文章），如果 userKey 相等，接着比较 Trailer，如果相等，则找到目标节点；Trailer 越大，说明 key 越小（Trailer 大说明版本更新，应该排在前面），如果 key 的 Trailer 大于了 nextTrailer，那就每必要往后找了，因为后面的 Trailer 更小，反之，继续遍历下一节点。</p>
<p>到这里，暂且介绍完了 skiplist 最基本的方法 – 创建、添加、查找，根据方法的实现可以帮助大家更清晰的认识 Pebble 对 Skiplist 的实现原理及使用方式。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文主要通过对源码解析，介绍了 Pebble 如何实现一个高性能无锁的 Skiplist，并介绍了 Skiplist 的几种最基本的方法，便于加深大家对 Skiplist 的理解，也利于后续源码探索。</p>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#Pebble" >
    <span class="tag-code">Pebble</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2022/02/16/2022-02-16-pebble_write_src_s/">
        <span class="nav-arrow">← </span>
        
          Pebble 源码剖析-写入流程(续)
        
      </a>
    
    
      <a class="nav-right" href="/2022/12/04/2022-12-04-lucene-DirectWriter/">
        
          lucene 编码技术 - DirectWriter
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
    <!-- 二维码 END -->
    
      <!-- Gitment START -->
      <div id="comments"></div>
      <!-- Gitment END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-nav-text">数据结构</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#Skiplist"><span class="toc-nav-text">Skiplist</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#node"><span class="toc-nav-text">node</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-nav-text">方法实现</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%88%9B%E5%BB%BA%E8%B7%B3%E8%A1%A8"><span class="toc-nav-text">创建跳表</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E6%B7%BB%E5%8A%A0-key-value"><span class="toc-nav-text">添加 key-value</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E6%9F%A5%E6%89%BE-key"><span class="toc-nav-text">查找 key</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-nav-text">总结</span></a></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'https://zhenyuxie.github.io/2022/02/26/2022-02-16-pebble_skiplist/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', '/css/images/error_icon.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== '/css/images/error_icon.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>




  <script>
    var gitmentConfig = "zhenyuyxie";
    if (gitmentConfig !== 'undefined') {
      var gitment = new Gitment({
        id: "Pebble 源码剖析 - Skiplist",
        owner: "zhenyuyxie",
        repo: "zhenyuxie.github.io",
        oauth: {
          client_id: "1f2036d171d35790250b",
          client_secret: "d1f9e1ae4ea60f6783f5dace256aec77eed5d99b"
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  </script>




    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2023 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      hljs.configure({useBR: true});
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/js/script.js"></script>


  </body>
</html>