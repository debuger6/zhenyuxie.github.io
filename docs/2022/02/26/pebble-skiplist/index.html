<!doctype html><html lang=zh-cn data-theme=light><head><meta charset=utf-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: light)"><meta name=generator content="Hugo 0.109.0"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_16x16_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_32_32_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="Pebble 源码剖析 - Skiplist"><meta itemprop=description content="Pebble 是 Cockroach  参考 RocksDB 并用 Go 语言开发的高性能 KV 存储引擎."><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="/imgs/hugo_next_avatar.png"><meta itemprop=keywords content="Pebble"><meta property="og:type" content="article"><meta property="og:title" content="Pebble 源码剖析 - Skiplist"><meta property="og:description" content="Pebble 是 Cockroach  参考 RocksDB 并用 Go 语言开发的高性能 KV 存储引擎."><meta property="og:image" content="/imgs/hugo_next_avatar.png"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="/2022/02/26/pebble-skiplist/"><meta property="og:site_name" content="debuger"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="debuger"><meta property="article:published_time" content="2022-02-26 23:27:00 +0000 UTC"><meta property="article:modified_time" content="2022-02-26 23:27:00 +0000 UTC"><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/font-awesome/6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.css><link rel=stylesheet href=/css/main.min.42b65f4b5d8fdb26467483a54df0d4f1570d2f58db628dde5a9075d4ba6c423c.css><style type=text/css>.post-footer,.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":true,"isHome":false,"isPage":true,"math":{"js":{"file":"es5/tex-mml-chtml.js","name":"mathjax","version":"3.2.0"},"render":"mathjax"},"path":"pebble-skiplist","permalink":"/2022/02/26/pebble-skiplist/","title":"Pebble 源码剖析 - Skiplist","waline":{"js":[{"alias":"waline","alias_name":"@waline/client","file":"dist/pageview.js","name":"pageview","version":"2.13.0"},{"alias":"waline","alias_name":"@waline/client","file":"dist/comment.js","name":"comment","version":"2.13.0"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>Pebble 源码剖析 - Skiplist - debuger</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label="Toggle navigation bar" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>debuger</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>大道至简</p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about.html class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>技术博客
<span class=badge>18</span></a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>Search</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=Searching... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>TOC</li><li class=sidebar-nav-overview>Overview</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><ul><li><a href=#数据结构>数据结构</a><ul><li><a href=#skiplist>Skiplist</a></li><li><a href=#node>node</a></li></ul></li><li><a href=#方法实现>方法实现</a><ul><li><a href=#创建跳表>创建跳表</a></li><li><a href=#添加-key-value>添加 key-value</a></li><li><a href=#查找-key>查找 key</a></li></ul></li><li><a href=#总结>总结</a></li></ul></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=debuger src=/imgs/img-lazy-loading.gif data-src=/imgs/hugo_next_avatar.png><p class=site-author-name itemprop=name>debuger</p><div class=site-description itemprop=description>Simple is the best.</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>18</span>
<span class=site-state-item-name>Posts</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>13</span>
<span class=site-state-item-name>Categories</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>19</span>
<span class=site-state-item-name>Tags</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://www.zhihu.com/people/xzy-51-38 title="知乎 → https://www.zhihu.com/people/xzy-51-38" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-book fa-fw hvr-icon"></i>知乎</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title="Creative Commons"><img src=/imgs/img-lazy-loading.gif data-src=/imgs/cc/big/by_nc_sa.svg alt="Creative Commons"></a></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>Web Status</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>Running:</div><div class=item-count id=runTimes data-publishdate=2022-01-20T22:00:00+00:00></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>Visitors:</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>Views:</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>Words:</div><div class=item-count id=wordsCount data-count=50640></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>ReadTime:</div><div class=item-count id=readTimes data-times=112></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>Last Update:</div><div class=item-count id=last-push-date data-lastpushdate=2023-09-05T23:00:00+00:00></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-comments class="button goto-comments" title="Go to Comment"><i class="fas fa-comments"></i></div><div id=goto-gtranslate class=button title="Multilingual translation"><i class="fas fa-globe"></i></div><div id=toggle-theme class=button title="Change Theme"><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title="Back to Top"><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a>
<a href=https://github.com/debuger6 rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><script type=text/javascript src=//sidecar.gitter.im/dist/sidecar.v1.js async></script>
<script type=text/javascript>((window.gitter={}).chat={}).options={room:"hugo-next/community"}</script><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=/2022/02/26/pebble-skiplist/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/hugo_next_avatar.png"><meta itemprop=name content="debuger"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="debuger"><meta itemprop=description content="Simple is the best."></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="Pebble 源码剖析 - Skiplist"><meta itemprop=description content="Pebble 是 Cockroach  参考 RocksDB 并用 Go 语言开发的高性能 KV 存储引擎."></span><header class=post-header><h1 class=post-title itemprop="name headline">Pebble 源码剖析 - Skiplist</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i></span>
<span class=post-meta-item-text>Publish on:</span>
<time title="Publish on:2022-02-26 23:27:00 +0000 UTC" itemprop="dateCreated datePublished" datetime="2022-02-26 23:27:00 +0000 UTC">2022-02-26</time></span>
<span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i></span>
<span class=post-meta-item-text>Classify at:</span>
<span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/pebble itemprop=url rel=index><span itemprop=name>pebble</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=Words><span class=post-meta-item-icon><i class="far fa-file-word"></i></span>
<span class=post-meta-item-text>Words:</span><span>3022</span></span>
<span class=post-meta-item title=Read><span class=post-meta-item-icon><i class="far fa-clock"></i></span>
<span class=post-meta-item-text>Read:&ap;</span>
<span>7min</span></span>
<span class=post-meta-item title=Views><span class=post-meta-item-icon><i class="far fa-eye"></i></span>
<span class=post-meta-item-text>Views:</span>
<span id=busuanzi_value_page_pv class=waline-pageview-count data-path=/2022/02/26/pebble-skiplist/><i class="fa fa-sync fa-spin"></i></span></span>
<span class=post-meta-item title=Comments><span class=post-meta-item-icon><i class="far fa-comments"></i></span>
<span class=post-meta-item-text>Comments:</span>
<span class=waline-comment-count data-path=/2022/02/26/pebble-skiplist/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>本章主要从源码角度来分析 Pebble 对 Skiplist（跳表）的高性能设计，对于跳表的介绍及原理可以参考
<a href=https://baike.baidu.com/item/%E8%B7%B3%E8%A1%A8/22819833 title=百科 rel="noopener external nofollow noreferrer" target=_blank class=exturl>百科
<i class="fa fa-external-link-alt"></i>
</a>或网上其他文章，本文不做冗余介绍。</p><h3 id=数据结构>数据结构</h3><p>容易想到，跳表和普通链表类似，由多个节点组成，不同的是，每个节点有多层，因此会有多个 next 指针指向每层的下个节点，如下图：</p><p><img src=/imgs/img-lazy-loading.gif data-src=/images/pebble/800px-Skip_list.svg.png alt=800px-Skip_list.svg></p><p>跳表的逻辑结构很容易理解，使用链表这种数据结构实现非常直观。但是 Pebble 从高性能的角度出发，底层存储并未使用链表，而使用的是数组，通过 CAS 无锁技术，在并发场景下具备高效的性能。下面先来看看源码中几个关键的数据结构。</p><h4 id=skiplist>Skiplist</h4><p>Skiplist 源码定义如下:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Skiplist</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>arena</span>  <span style=color:#f92672>*</span><span style=color:#a6e22e>Arena</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>cmp</span>    <span style=color:#a6e22e>base</span>.<span style=color:#a6e22e>Compare</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>head</span>   <span style=color:#f92672>*</span><span style=color:#a6e22e>node</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>tail</span>   <span style=color:#f92672>*</span><span style=color:#a6e22e>node</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>height</span> <span style=color:#66d9ef>uint32</span> <span style=color:#75715e>// Current height. 1 &lt;= height &lt;= maxHeight. CAS.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// If set to true by tests, then extra delays are added to make it easier to
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// detect unusual race conditions.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>testing</span> <span style=color:#66d9ef>bool</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Arena</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>n</span>   <span style=color:#66d9ef>uint64</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>buf</span> []<span style=color:#66d9ef>byte</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可以看到整个结构比较简单，arena 代表跳表数据存储的地方，是一个固定大小的 buffer；cmp 代表跳表内节点值的比较函数；head 为头节点；tail 为尾节点；height 代表跳表的高度（节点当前最大层数）；testing 为测试时候使用，可以忽略。</p><h4 id=node>node</h4><p>再来看看里面核心结构 node 的定义：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>node</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Immutable fields, so no need to lock to access key.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>keyOffset</span> <span style=color:#66d9ef>uint32</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>keySize</span>   <span style=color:#66d9ef>uint32</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>valueSize</span> <span style=color:#66d9ef>uint32</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>allocSize</span> <span style=color:#66d9ef>uint32</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>tower</span> [<span style=color:#a6e22e>maxHeight</span>]<span style=color:#a6e22e>links</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>links</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>nextOffset</span> <span style=color:#66d9ef>uint32</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>prevOffset</span> <span style=color:#66d9ef>uint32</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>keyOffset 代表 key 在 arena 中的偏移，keySize 代表 key 的大小；valueSize 代表 value 的大小；allocSize 代表 node 占用的内存大小；tower 是一个数组，每个元素相当于每层的 pre-next 指针，指向各层的前一个节点和后一个节点。</p><p>可以看出 node 并未存储 key-value 的具体值，而是存的偏移和大小，value 的偏移并未存储，因为可以通过 keyOffset 和 keySize 间接计算出来。tower 比较形象，可以把节点看做塔一样，有多层，每层通过双向指针串联前后节点。因此 Skiplist 逻辑上是一个双向链表，Skiplist 在 Pebble 中的物理结构如下图：</p><p><img src=/imgs/img-lazy-loading.gif data-src=/images/pebble/skiplist_arena.png alt=image-20220215232733854></p><blockquote><p>tower 指向的 node 个数有多个，图上只画了一对 link 表示节点在某层的前后节点偏移。</p></blockquote><h3 id=方法实现>方法实现</h3><p>了解 Skiplist 的数据结构定义后，接下来，看看如果操作 Skiplist，即 Skiplist 的相关方法实现。</p><h4 id=创建跳表>创建跳表</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>NewSkiplist</span>(<span style=color:#a6e22e>arena</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Arena</span>, <span style=color:#a6e22e>cmp</span> <span style=color:#a6e22e>base</span>.<span style=color:#a6e22e>Compare</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>Skiplist</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>skl</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>Skiplist</span>{}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>skl</span>.<span style=color:#a6e22e>Reset</span>(<span style=color:#a6e22e>arena</span>, <span style=color:#a6e22e>cmp</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>skl</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>创建 Skiplist 时，需要由外部传入 arena 和 cmp，Skiplist 的容量和比较函数由使用者决定。这里会调用 Reset 对 Skiplist 进行初始化操作，来看看具体实现逻辑：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Skiplist</span>) <span style=color:#a6e22e>Reset</span>(<span style=color:#a6e22e>arena</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Arena</span>, <span style=color:#a6e22e>cmp</span> <span style=color:#a6e22e>base</span>.<span style=color:#a6e22e>Compare</span>) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Allocate head and tail nodes.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>head</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>newRawNode</span>(<span style=color:#a6e22e>arena</span>, <span style=color:#a6e22e>maxHeight</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		panic(<span style=color:#e6db74>&#34;arenaSize is not large enough to hold the head node&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>head</span>.<span style=color:#a6e22e>keyOffset</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>tail</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>newRawNode</span>(<span style=color:#a6e22e>arena</span>, <span style=color:#a6e22e>maxHeight</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		panic(<span style=color:#e6db74>&#34;arenaSize is not large enough to hold the tail node&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>tail</span>.<span style=color:#a6e22e>keyOffset</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Link all head/tail levels together.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>headOffset</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>arena</span>.<span style=color:#a6e22e>getPointerOffset</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>head</span>))
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>tailOffset</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>arena</span>.<span style=color:#a6e22e>getPointerOffset</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>tail</span>))
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>maxHeight</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>head</span>.<span style=color:#a6e22e>tower</span>[<span style=color:#a6e22e>i</span>].<span style=color:#a6e22e>nextOffset</span> = <span style=color:#a6e22e>tailOffset</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>tail</span>.<span style=color:#a6e22e>tower</span>[<span style=color:#a6e22e>i</span>].<span style=color:#a6e22e>prevOffset</span> = <span style=color:#a6e22e>headOffset</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>*</span><span style=color:#a6e22e>s</span> = <span style=color:#a6e22e>Skiplist</span>{
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>arena</span>:  <span style=color:#a6e22e>arena</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>cmp</span>:    <span style=color:#a6e22e>cmp</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>head</span>:   <span style=color:#a6e22e>head</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>tail</span>:   <span style=color:#a6e22e>tail</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>height</span>: <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>既然是初始化，那肯定是对 Skiplist 里面的成员变量进行初始化操作，arena 和 cmp 已经有了，很明显还需要对 head、tail、height 进行初始化赋值。首先通过 newRawNode 创建 head 节点和 tail 节点，由于 head 和 tail 不存储 key-value，因此 keyOffset 都初始化为 0，代表没有具体值；然后获取 head 和 tail 在 arena 中的偏移位置，并初始化 head.tower 的 nextOffset 和 tail.tower 的 prevOffset。</p><p>最后，Skiplist 中个成员变量初始化完毕，Skiplist 便算是创建成功了。接下来看看 newRawNode 的实现逻辑。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>newRawNode</span>(<span style=color:#a6e22e>arena</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Arena</span>, <span style=color:#a6e22e>height</span> <span style=color:#66d9ef>uint32</span>, <span style=color:#a6e22e>keySize</span>, <span style=color:#a6e22e>valueSize</span> <span style=color:#66d9ef>uint32</span>) (<span style=color:#a6e22e>nd</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>node</span>, <span style=color:#a6e22e>err</span> <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Compute the amount of the tower that will never be used, since the height
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// is less than maxHeight.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>unusedSize</span> <span style=color:#f92672>:=</span> uint32((<span style=color:#a6e22e>maxHeight</span> <span style=color:#f92672>-</span> int(<span style=color:#a6e22e>height</span>)) <span style=color:#f92672>*</span> <span style=color:#a6e22e>linksSize</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>nodeSize</span> <span style=color:#f92672>:=</span> uint32(<span style=color:#a6e22e>maxNodeSize</span>) <span style=color:#f92672>-</span> <span style=color:#a6e22e>unusedSize</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>nodeOffset</span>, <span style=color:#a6e22e>allocSize</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>arena</span>.<span style=color:#a6e22e>alloc</span>(<span style=color:#a6e22e>nodeSize</span><span style=color:#f92672>+</span><span style=color:#a6e22e>keySize</span><span style=color:#f92672>+</span><span style=color:#a6e22e>valueSize</span>, <span style=color:#a6e22e>align4</span>, <span style=color:#a6e22e>unusedSize</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>nd</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>node</span>)(<span style=color:#a6e22e>arena</span>.<span style=color:#a6e22e>getPointer</span>(<span style=color:#a6e22e>nodeOffset</span>))
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>nd</span>.<span style=color:#a6e22e>keyOffset</span> = <span style=color:#a6e22e>nodeOffset</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>nodeSize</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>nd</span>.<span style=color:#a6e22e>keySize</span> = <span style=color:#a6e22e>keySize</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>nd</span>.<span style=color:#a6e22e>valueSize</span> = <span style=color:#a6e22e>valueSize</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>nd</span>.<span style=color:#a6e22e>allocSize</span> = <span style=color:#a6e22e>allocSize</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>newRawNode 会在 arena 中分配 node 所需内存大小，然后将成员变量的值存入 arena 中。由于节点的高度，即 tower 的层数小于等于 maxHeight，height 到 maxHeight 之间的 links 并不会使用，这里要计算出未使用的大小，然后再用节点最大大小减去未使用大小得到节点实际大小；</p><p>知道节点的大小后，便可以在 arena 中分配相应大小的内存空间，最后对 node 成员变量初始化，初始化的值则保存在 arena 中。</p><blockquote><p>newRawNode 中分配 node 的内存时，采用 4 字节对齐，原因是 node 的每个变量都是 uint32（tower 元素中的成员变量也是），因此按 4 字节对齐时，cpu 访问内存获取变量值时更加高效，提升访存性能。字节对齐的好处可参考网上其他文章。</p></blockquote><h4 id=添加-key-value>添加 key-value</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Skiplist</span>) <span style=color:#a6e22e>Add</span>(<span style=color:#a6e22e>key</span> <span style=color:#a6e22e>base</span>.<span style=color:#a6e22e>InternalKey</span>, <span style=color:#a6e22e>value</span> []<span style=color:#66d9ef>byte</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ins</span> <span style=color:#a6e22e>Inserter</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>addInternal</span>(<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>value</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>ins</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Skiplist</span>) <span style=color:#a6e22e>addInternal</span>(<span style=color:#a6e22e>key</span> <span style=color:#a6e22e>base</span>.<span style=color:#a6e22e>InternalKey</span>, <span style=color:#a6e22e>value</span> []<span style=color:#66d9ef>byte</span>, <span style=color:#a6e22e>ins</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Inserter</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 找到 key 要插入的位置
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>findSplice</span>(<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>ins</span>) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>ErrRecordExists</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>nd</span>, <span style=color:#a6e22e>height</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>newNode</span>(<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>value</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// node 在 arena 中的偏移
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>ndOffset</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>arena</span>.<span style=color:#a6e22e>getPointerOffset</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>nd</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>found</span> <span style=color:#66d9ef>bool</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>invalidateSplice</span> <span style=color:#66d9ef>bool</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; int(<span style=color:#a6e22e>height</span>); <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>prev</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ins</span>.<span style=color:#a6e22e>spl</span>[<span style=color:#a6e22e>i</span>].<span style=color:#a6e22e>prev</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>next</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ins</span>.<span style=color:#a6e22e>spl</span>[<span style=color:#a6e22e>i</span>].<span style=color:#a6e22e>next</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>prev</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>next</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>				panic(<span style=color:#e6db74>&#34;next is expected to be nil, since prev is nil&#34;</span>)
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>prev</span> = <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>head</span>
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>next</span> = <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>tail</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 获取 prev 和 next 的偏移
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#a6e22e>prevOffset</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>arena</span>.<span style=color:#a6e22e>getPointerOffset</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>prev</span>))
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>nextOffset</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>arena</span>.<span style=color:#a6e22e>getPointerOffset</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>next</span>))
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>nd</span>.<span style=color:#a6e22e>tower</span>[<span style=color:#a6e22e>i</span>].<span style=color:#a6e22e>init</span>(<span style=color:#a6e22e>prevOffset</span>, <span style=color:#a6e22e>nextOffset</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>nextPrevOffset</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>next</span>.<span style=color:#a6e22e>prevOffset</span>(<span style=color:#a6e22e>i</span>)
</span></span><span style=display:flex><span>      <span style=color:#75715e>// next 的 prevOffset 不指向 prevOffset
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>nextPrevOffset</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>prevOffset</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>prevNextOffset</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>prev</span>.<span style=color:#a6e22e>nextOffset</span>(<span style=color:#a6e22e>i</span>)
</span></span><span style=display:flex><span>        <span style=color:#75715e>// prev 的 nextOffset 指向 next，说明 next 的 prevOffset 还没来得及修改
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>				<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>prevNextOffset</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>nextOffset</span> {
</span></span><span style=display:flex><span>					<span style=color:#a6e22e>next</span>.<span style=color:#a6e22e>casPrevOffset</span>(<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>nextPrevOffset</span>, <span style=color:#a6e22e>prevOffset</span>)
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// cas 修改 prev 的 nextOffset
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>prev</span>.<span style=color:#a6e22e>casNextOffset</span>(<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>nextOffset</span>, <span style=color:#a6e22e>ndOffset</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// cas 修改 next 的 prevOffset
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>				<span style=color:#a6e22e>next</span>.<span style=color:#a6e22e>casPrevOffset</span>(<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>prevOffset</span>, <span style=color:#a6e22e>ndOffset</span>)
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>      <span style=color:#75715e>// cas 失败，说明其他线程成功插入节点，需要重新计算 key 插入的位置
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#a6e22e>prev</span>, <span style=color:#a6e22e>next</span>, <span style=color:#a6e22e>found</span> = <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>findSpliceForLevel</span>(<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>prev</span>)
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>found</span> {
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>					panic(<span style=color:#e6db74>&#34;how can another thread have inserted a node at a non-base level?&#34;</span>)
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>ErrRecordExists</span>
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>invalidateSplice</span> = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>invalidateSplice</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>ins</span>.<span style=color:#a6e22e>height</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> uint32(<span style=color:#ae81ff>0</span>); <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>height</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>ins</span>.<span style=color:#a6e22e>spl</span>[<span style=color:#a6e22e>i</span>].<span style=color:#a6e22e>prev</span> = <span style=color:#a6e22e>nd</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我们主要关注 addInternal，该方法利用循环+CAS，在并发场景下可以高效地插入节点。首先通过 findSplice 方法找到要插入的位置，位置保存在 ins 的 spl 中，该变量存储了每层的前后节点。找到位置后，创建节点并保存 key-value 值，然后再 for 循环中遍历每层的 prev 和 next，将节点插入 pre 和 next 之间，如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>+----------------+     +------------+     +----------------+
</span></span><span style=display:flex><span>|      prev      |     |     nd     |     |      next      |
</span></span><span style=display:flex><span>| prevNextOffset |----&gt;|            |     |                |
</span></span><span style=display:flex><span>|                |&lt;----| prevOffset |     |                |
</span></span><span style=display:flex><span>|                |     | nextOffset |----&gt;|                |
</span></span><span style=display:flex><span>|                |     |            |&lt;----| nextPrevOffset |
</span></span><span style=display:flex><span>+----------------+     +------------+     +----------------+
</span></span></code></pre></div><p>插入节点时，首先将 nd 的 prevOffset 和 nextOffset 指向 prev 和 next；然后通过 for+cas 修改 prev 的 nextOffset 再修改 next 的 prevOffset，如果修改成功，退出内存循环，继续处理下一层，否则重新计算 node 在当前层的插入位置，继续重试。</p><blockquote><p>注意，这里在更新 prev 的 nextOffset 和 next 的 prevOffset 前会先修正 next 的当前 prevOffset，因为可能存在另一个线程正在插入的节点是 prev，而 prev 的 nextOffset 已经指向了 next，但是 next 的 prevOffset 还未来得及指向 prev。为了保证 cas 正确性，需要帮助另一线程将 next 的 prevOffset 指向 prev。</p></blockquote><h4 id=查找-key>查找 key</h4><p>Skiplist 的查找及遍历都是通过迭代器 Iterator 实现的，这里只列出最基础的查找方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>it</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Iterator</span>) <span style=color:#a6e22e>seekForBaseSplice</span>(<span style=color:#a6e22e>key</span> []<span style=color:#66d9ef>byte</span>) (<span style=color:#a6e22e>prev</span>, <span style=color:#a6e22e>next</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>node</span>, <span style=color:#a6e22e>found</span> <span style=color:#66d9ef>bool</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ikey</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>base</span>.<span style=color:#a6e22e>MakeSearchKey</span>(<span style=color:#a6e22e>key</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>level</span> <span style=color:#f92672>:=</span> int(<span style=color:#a6e22e>it</span>.<span style=color:#a6e22e>list</span>.<span style=color:#a6e22e>Height</span>() <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>prev</span> = <span style=color:#a6e22e>it</span>.<span style=color:#a6e22e>list</span>.<span style=color:#a6e22e>head</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>prev</span>, <span style=color:#a6e22e>next</span>, <span style=color:#a6e22e>found</span> = <span style=color:#a6e22e>it</span>.<span style=color:#a6e22e>list</span>.<span style=color:#a6e22e>findSpliceForLevel</span>(<span style=color:#a6e22e>ikey</span>, <span style=color:#a6e22e>level</span>, <span style=color:#a6e22e>prev</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>found</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>level</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>				<span style=color:#75715e>// next is pointing at the target node, but we need to find previous on
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>				<span style=color:#75715e>// the bottom level.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>				<span style=color:#a6e22e>prev</span> = <span style=color:#a6e22e>it</span>.<span style=color:#a6e22e>list</span>.<span style=color:#a6e22e>getPrev</span>(<span style=color:#a6e22e>next</span>, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>level</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>level</span><span style=color:#f92672>--</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>该方法逻辑非常简单，初始查找节点为 head，然后从最高层开始查找，如果找到目标节点（注：next 才是目标节点），则将 next 0 层的前一个节点赋给 prev（必须最底层才能代表真正的前节点）；如果没有找到，则继续根据 prev 节点查找下一层，直到 0 层如果还未找到，说明目标值不存在。</p><p>我们继续看下 findSpliceForLevel 的逻辑：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Skiplist</span>) <span style=color:#a6e22e>findSpliceForLevel</span>(
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>key</span> <span style=color:#a6e22e>base</span>.<span style=color:#a6e22e>InternalKey</span>, <span style=color:#a6e22e>level</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>start</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>node</span>,
</span></span><span style=display:flex><span>) (<span style=color:#a6e22e>prev</span>, <span style=color:#a6e22e>next</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>node</span>, <span style=color:#a6e22e>found</span> <span style=color:#66d9ef>bool</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>prev</span> = <span style=color:#a6e22e>start</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Assume prev.key &lt; key.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>next</span> = <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>getNext</span>(<span style=color:#a6e22e>prev</span>, <span style=color:#a6e22e>level</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>next</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>tail</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>offset</span>, <span style=color:#a6e22e>size</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>next</span>.<span style=color:#a6e22e>keyOffset</span>, <span style=color:#a6e22e>next</span>.<span style=color:#a6e22e>keySize</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>nextKey</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>arena</span>.<span style=color:#a6e22e>buf</span>[<span style=color:#a6e22e>offset</span> : <span style=color:#a6e22e>offset</span><span style=color:#f92672>+</span><span style=color:#a6e22e>size</span>]
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> int32(<span style=color:#a6e22e>size</span>) <span style=color:#f92672>-</span> <span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>cmp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>cmp</span>(<span style=color:#a6e22e>key</span>.<span style=color:#a6e22e>UserKey</span>, <span style=color:#a6e22e>nextKey</span>[:<span style=color:#a6e22e>n</span>])
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>cmp</span> &lt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>			<span style=color:#75715e>// We are done for this level, since prev.key &lt; key &lt; next.key.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>cmp</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>			<span style=color:#75715e>// User-key equality.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>nextTrailer</span> <span style=color:#66d9ef>uint64</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>n</span> <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>nextTrailer</span> = <span style=color:#a6e22e>binary</span>.<span style=color:#a6e22e>LittleEndian</span>.<span style=color:#a6e22e>Uint64</span>(<span style=color:#a6e22e>nextKey</span>[<span style=color:#a6e22e>n</span>:])
</span></span><span style=display:flex><span>			} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>nextTrailer</span> = uint64(<span style=color:#a6e22e>base</span>.<span style=color:#a6e22e>InternalKeyKindInvalid</span>)
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>key</span>.<span style=color:#a6e22e>Trailer</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>nextTrailer</span> {
</span></span><span style=display:flex><span>				<span style=color:#75715e>// Internal key equality.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>				<span style=color:#a6e22e>found</span> = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>key</span>.<span style=color:#a6e22e>Trailer</span> &gt; <span style=color:#a6e22e>nextTrailer</span> {
</span></span><span style=display:flex><span>				<span style=color:#75715e>// We are done for this level, since prev.key &lt; key &lt; next.key.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>				<span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Keep moving right on this level.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>prev</span> = <span style=color:#a6e22e>next</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Skiplist</span>) <span style=color:#a6e22e>getNext</span>(<span style=color:#a6e22e>nd</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>node</span>, <span style=color:#a6e22e>h</span> <span style=color:#66d9ef>int</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>node</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>offset</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>LoadUint32</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>nd</span>.<span style=color:#a6e22e>tower</span>[<span style=color:#a6e22e>h</span>].<span style=color:#a6e22e>nextOffset</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>node</span>)(<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>arena</span>.<span style=color:#a6e22e>getPointer</span>(<span style=color:#a6e22e>offset</span>))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>从 start 节点开始（start.key &lt; key），获取 next 节点，getNext 内部通过原子操作获取 next 的偏移，有了偏移便可通过 arena 获取 buffer 中的 nextKey，然后比较 key 和 nextKey 的原始值（去掉 key 的后 8 位 Trailer，key 的格式参考之前的文章），如果 userKey 相等，接着比较 Trailer，如果相等，则找到目标节点；Trailer 越大，说明 key 越小（Trailer 大说明版本更新，应该排在前面），如果 key 的 Trailer 大于了 nextTrailer，那就每必要往后找了，因为后面的 Trailer 更小，反之，继续遍历下一节点。</p><p>到这里，暂且介绍完了 skiplist 最基本的方法 &ndash; 创建、添加、查找，根据方法的实现可以帮助大家更清晰的认识 Pebble 对 Skiplist 的实现原理及使用方式。</p><h3 id=总结>总结</h3><p>本文主要通过对源码解析，介绍了 Pebble 如何实现一个高性能无锁的 Skiplist，并介绍了 Skiplist 的几种最基本的方法，便于加深大家对 Skiplist 的理解，也利于后续源码探索。</p></div><footer class=post-footer><div class=post-tags><a href=/tags/pebble>Pebble</a></div><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=post-copyright><img src=/imgs/cc/cc.svg width=75 height=75 align=right><ul><li class=post-copyright-title><strong>Post Title:</strong>
Pebble 源码剖析 - Skiplist</li><li class=post-copyright-author><strong>Written By:</strong>
debuger</li><li class=post-copyright-link><strong>Post Link:</strong>
<a id=post-cr-link href=/2022/02/26/pebble-skiplist/ title="Pebble 源码剖析 - Skiplist">/2022/02/26/pebble-skiplist/</a></li><li class=post-copyright-license><strong>Copyright Notice:</strong>
All articles in this blog are licensed under <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh>BY-NC-SA</a> unless stating additionally.</li></ul></div><div class=followme><span>Welcome to my other publishing channels</span><div class=social-list><div class=social-item><a target=_blank class=social-link href=/images/wechat_channel.jpg><span class=icon><i class="fab fa-weixin"></i></span>
<span class=label>WeChat</span></a></div><div class=social-item><a target=_blank class=social-link href=/atom.xml><span class=icon><i class="fa fa-rss"></i></span>
<span class=label>RSS</span></a></div></div></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/2022/12/04/lucene-dw/ rel=next title="lucene 编码技术 - DirectWriter"><i class="fa fa-chevron-left"></i> lucene 编码技术 - DirectWriter</a></div><div class="post-nav-prev post-nav-item"><a href=/2022/01/24/pebble-write-s/ rel=prev title="Pebble 源码剖析-写入流程(续)">Pebble 源码剖析-写入流程(续)
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div id=comments class=post-comments><div class=comment-head><div class=comment-headline><i class="fas fa-comments fa-fw"></i>
<span>Comments</span></div></div><div class=comment-wrap><div><div class=comment-loading><i class="fa fa-sync fa-spin"></i></div><div class=giscus-container></div></div></div></div></div></main><footer class=footer><div class=footer-inner><div id=gtranslate class=google-translate><i class="fa fa-language"></i><div id=google_translate_element></div></div><div class=copyright>&copy;
<span itemprop=copyrightYear>2010 - 2023</span>
<span class=with-love><i class="fa fa-heart"></i></span>
<span class=author itemprop=copyrightHolder>debuger</span></div><div class=powered-by>Power by <a href=https://gohugo.io title=0.109.0 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.4.0 target=_blank>Hugo NexT.Gemini</a></div></div></footer><script type=text/javascript src=https://cdn.staticfile.org/animejs/3.2.1/anime.min.js defer></script>
<script type=text/javascript src=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.js defer></script>
<script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"busuanzi":{"pageview":true},"copybtn":true,"darkmode":false,"giscus":{"cfg":{"category":"Announcements","categoryid":"DIC_kwDOIqmyr84CTQGv","emit":false,"inputposition":"top","mapping":"title","reactions":true,"repo":"debuger6/zhenyuxie.github.io","repoid":"R_kgDOIqmyrw","theme":"preferred_color_scheme"},"js":"https://giscus.app/client.js"},"hostname":"/","i18n":{"ds_day":" Day Ago","ds_days":" Day ","ds_hour":" Hour Ago","ds_hours":" Hour ","ds_just":"Just","ds_min":" Min Ago","ds_mins":" Min","ds_month":" Month Ago","ds_years":" Year ","empty":"We didn't find any results for the search: ${query}","hits":"","hits_time":"${hits} results found in ${time} ms","placeholder":"Searching..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":230},"statis":{"enable":true,"plugin":"busuanzi"},"vendor":{"plugins":"qiniu","router":"https://cdn.staticfile.org"},"version":"4.4.0","waline":{"cfg":{"comment":true,"emoji":false,"imguploader":false,"pageview":true,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o","reaction":true,"reactiontext":["点赞","得意"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"serverurl":"https://walinejs.comment.lithub.cc","sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"waline","file":"dist/waline.css","name":"@waline/client","version":"2.13.0"},"js":{"alias":"waline","file":"dist/waline.js","name":"@waline/client","version":"2.13.0"}}}</script><script type=text/javascript src=/js/main.min.37028fbafbd97fd89808b4c7b5a3a81f01ed0ab24001d273d774f9546a0e9170.js defer></script>
<script type=text/javascript src=/js/math.min.95d37ca8344f2f635c0f13f77cc75191efb6cdf99093ed73203a86e05f995fbb.js defer></script></body></html>