<!doctype html><html lang=zh-cn data-theme=light><head><meta charset=utf-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: light)"><meta name=generator content="Hugo 0.109.0"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_16x16_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_32_32_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="Fastest table sort in the West - Redesigning DuckDB’s sort"><meta itemprop=description content="Simple is the best."><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="/imgs/hugo_next_avatar.png"><meta itemprop=keywords content="radix sort,merge sort,database"><meta property="og:type" content="article"><meta property="og:title" content="Fastest table sort in the West - Redesigning DuckDB’s sort"><meta property="og:description" content="Simple is the best."><meta property="og:image" content="/imgs/hugo_next_avatar.png"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="/post/2023-04-16-fastest-table-sort/"><meta property="og:site_name" content="debuger"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="debuger"><meta property="article:published_time" content="2023-04-16 17:53:00 +0800 CST"><meta property="article:modified_time" content="2023-04-16 17:53:00 +0800 CST"><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/font-awesome/6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.css><link rel=stylesheet href=/css/main.min.42b65f4b5d8fdb26467483a54df0d4f1570d2f58db628dde5a9075d4ba6c423c.css><style type=text/css>.post-footer,.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":true,"isHome":false,"isPage":true,"math":{"js":{"file":"es5/tex-mml-chtml.js","name":"mathjax","version":"3.2.0"},"render":"mathjax"},"path":"2023-04-16-fastest-table-sort","permalink":"/post/2023-04-16-fastest-table-sort/","title":"Fastest table sort in the West - Redesigning DuckDB’s sort","waline":{"js":[{"alias":"waline","alias_name":"@waline/client","file":"dist/pageview.js","name":"pageview","version":"2.13.0"},{"alias":"waline","alias_name":"@waline/client","file":"dist/comment.js","name":"comment","version":"2.13.0"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>Fastest table sort in the West - Redesigning DuckDB’s sort - debuger</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label="Toggle navigation bar" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>debuger</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>大道至简</p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about.html class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>技术博客
<span class=badge>12</span></a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>Search</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=Searching... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>TOC</li><li class=sidebar-nav-overview>Overview</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><ul><li><a href=#排序关系数据>排序关系数据</a></li><li><a href=#二进制字符串比较>二进制字符串比较</a></li><li><a href=#基数排序>基数排序</a></li><li><a href=#两阶段并行排序>两阶段并行排序</a></li><li><a href=#列还是行>列还是行？</a></li><li><a href=#外部排序>外部排序</a></li><li><a href=#comparison-with-other-systems>Comparison with Other Systems</a><ul><li><a href=#结论>结论</a></li></ul></li><li><a href=#总结>总结</a></li><li><a href=#reference>Reference</a></li></ul></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=debuger src=/imgs/img-lazy-loading.gif data-src=/imgs/hugo_next_avatar.png><p class=site-author-name itemprop=name>debuger</p><div class=site-description itemprop=description>Simple is the best.</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>12</span>
<span class=site-state-item-name>Posts</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>7</span>
<span class=site-state-item-name>Categories</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>10</span>
<span class=site-state-item-name>Tags</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/zhenyuxie title="Github → https://github.com/zhenyuxie" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>Github</a></span>
<span class=links-of-social-item><a href=https://www.zhihu.com/people/xzy-51-38 title="知乎 → https://www.zhihu.com/people/xzy-51-38" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-book fa-fw hvr-icon"></i>知乎</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title="Creative Commons"><img src=/imgs/img-lazy-loading.gif data-src=/imgs/cc/big/by_nc_sa.svg alt="Creative Commons"></a></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>Web Status</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>Running:</div><div class=item-count id=runTimes data-publishdate=2022-01-20T22:00:00+00:00></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>Visitors:</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>Views:</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>Words:</div><div class=item-count id=wordsCount data-count=35211></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>ReadTime:</div><div class=item-count id=readTimes data-times=77></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>Last Update:</div><div class=item-count id=last-push-date data-lastpushdate=2023-04-16T17:53:00+08:00></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-comments class="button goto-comments" title="Go to Comment"><i class="fas fa-comments"></i></div><div id=goto-gtranslate class=button title="Multilingual translation"><i class="fas fa-globe"></i></div><div id=toggle-theme class=button title="Change Theme"><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title="Back to Top"><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a>
<a href=https://github.com/zhenyuxie rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><script type=text/javascript src=//sidecar.gitter.im/dist/sidecar.v1.js async></script>
<script type=text/javascript>((window.gitter={}).chat={}).options={room:"hugo-next/community"}</script><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=/post/2023-04-16-fastest-table-sort/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/hugo_next_avatar.png"><meta itemprop=name content="debuger"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="debuger"><meta itemprop=description content="Simple is the best."></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="Fastest table sort in the West - Redesigning DuckDB’s sort"><meta itemprop=description content="本文是阅读 DuckDB 技术博客 《Fastest table sort in the West - Redesigning DuckDB’s sort》 后的翻译，同时插入了个人的理解和总结。 提到排序，可能很多同学会觉"></span><header class=post-header><h1 class=post-title itemprop="name headline">Fastest table sort in the West - Redesigning DuckDB’s sort</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i></span>
<span class=post-meta-item-text>Publish on:</span>
<time title="Publish on:2023-04-16 17:53:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2023-04-16 17:53:00 +0800 CST">2023-04-16</time></span>
<span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i></span>
<span class=post-meta-item-text>Classify at:</span>
<span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/%E6%95%B0%E6%8D%AE%E5%BA%93 itemprop=url rel=index><span itemprop=name>数据库</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=Words><span class=post-meta-item-icon><i class="far fa-file-word"></i></span>
<span class=post-meta-item-text>Words:</span><span>4809</span></span>
<span class=post-meta-item title=Read><span class=post-meta-item-icon><i class="far fa-clock"></i></span>
<span class=post-meta-item-text>Read:&ap;</span>
<span>10min</span></span>
<span class=post-meta-item title=Views><span class=post-meta-item-icon><i class="far fa-eye"></i></span>
<span class=post-meta-item-text>Views:</span>
<span id=busuanzi_value_page_pv class=waline-pageview-count data-path=/post/2023-04-16-fastest-table-sort/><i class="fa fa-sync fa-spin"></i></span></span>
<span class=post-meta-item title=Comments><span class=post-meta-item-icon><i class="far fa-comments"></i></span>
<span class=post-meta-item-text>Comments:</span>
<span class=waline-comment-count data-path=/post/2023-04-16-fastest-table-sort/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><blockquote><p>本文是阅读 DuckDB 技术博客 《Fastest table sort in the West - Redesigning DuckDB’s sort》 后的翻译，同时插入了个人的理解和总结。</p></blockquote><p>提到排序，可能很多同学会觉得这种常规操作 so easy，各种排序算法都比较成熟，很多语言的标准库都提供了排序算法的实现，研究的意义不是很大。但是在数据库系统中，排序不是简单针对一批数值或者字符串，而是整个数据表。排序涉及复杂的比较和数据移动，而且对于内存和外存考虑点也不尽相同，要实现一个高效灵活的排序算法不是一件容易的事情。</p><p>DuckDB 在排序上做了很多优化，性能也非常亮眼，我们来看看 DuckDB 究竟在排序上做了哪些优化。</p><h3 id=排序关系数据>排序关系数据</h3><p>排序是计算机科学中充分研究的问题之一，它是数据管理的一个重要方面。对排序算法的研究往往聚焦于对大型数组或键值对。但是这并没有覆盖到在数据库系统中怎么实现排序。对数据表排序远不止对大量整数数组排序那么简单！</p><p>考虑以下对 TPC-DS 表片段的示例查询：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> c_customer_sk, c_birth_country, c_birth_year
</span></span><span style=display:flex><span><span style=color:#66d9ef>FROM</span> customer
</span></span><span style=display:flex><span><span style=color:#66d9ef>ORDER</span> <span style=color:#66d9ef>BY</span> c_birth_country <span style=color:#66d9ef>DESC</span>, c_birth_year <span style=color:#66d9ef>ASC</span> NULLS <span style=color:#66d9ef>LAST</span>;
</span></span></code></pre></div><p>结果：</p><table><thead><tr><th style=text-align:center>c_customer_sk</th><th style=text-align:center>c_birth_country</th><th style=text-align:center>c_birth_year</th></tr></thead><tbody><tr><td style=text-align:center>64760</td><td style=text-align:center>NETHERLANDS</td><td style=text-align:center>1991</td></tr><tr><td style=text-align:center>75011</td><td style=text-align:center>NETHERLANDS</td><td style=text-align:center>1992</td></tr><tr><td style=text-align:center>89949</td><td style=text-align:center>NETHERLANDS</td><td style=text-align:center>1992</td></tr><tr><td style=text-align:center>90766</td><td style=text-align:center>NETHERLANDS</td><td style=text-align:center>NULL</td></tr><tr><td style=text-align:center>42927</td><td style=text-align:center>GERMANY</td><td style=text-align:center>1924</td></tr></tbody></table><p>数据首先按照 <code>c_birth_country</code> 降序排序，在 <code>c_birth_country</code> 相同的情况下按 <code>c_birth_year</code> 升序排序，NULL 值被当做最大值处理。整行数据被重新排序后，不仅仅是参与排序的字段列被重排，其他未在 ORDER BY 中的列（称为 <code>“payload columns”</code>）也会被重排，如上述例子中的 <code>c_customer_sk</code>。</p><p>可以很容易地使用任何排序算法，如 C++ 中的 std::sort 对数据排序，尽管 std::sort 是一个十分出色的算法，但它仍然是一种单线程方法，无法有效地按多列进行排序，因为函数调用开销会很快占据排序时间。下面我们将讨论为什么会这样。</p><p>排序的成本主要是<strong>比较值</strong>和<strong>移动数据</strong>。能够让这两个操作代价更低的任何事情都会对总运行时间产生重大影响。</p><p>当我们有多个 ORDER BY 子句时，有两种明显的方法可以实现比较器：</p><ol><li>遍历子句：比较列，直到我们找到一个不相等的列，或者直到我们比较了所有列。这已经相当复杂了，因为对行数据进行比较时，需要循环比较所有列（函数调用开销大），判断大小（一个循环内部需要包含一个 if/else，<strong>分支预测降低 cpu 执行效率</strong>），如果是列存存储，那么在比较不同列时，会造成内存的随机访问（读完一行中的 a 列，然后读 b 列，… ，不同列在物理上不连续，容易导致 <strong>cache missing</strong>）</li><li>按第一个子句完全排序数据，然后按第二个子句排序，但仅对第一个子句相等的数据排序，依此类推。当有很多重复值时，这种方法效率特别低，因为它需要多次遍历数据。</li></ol><p>针对上述两种方法，这里举个简单例子解释下更容易明白。假设有数据表 t1 如下：</p><table><thead><tr><th style=text-align:center>id</th><th style=text-align:center>city</th><th style=text-align:center>name</th></tr></thead><tbody><tr><td style=text-align:center>1</td><td style=text-align:center>BeiJing</td><td style=text-align:center>Zhang</td></tr><tr><td style=text-align:center>2</td><td style=text-align:center>ChengDu</td><td style=text-align:center>Xie</td></tr><tr><td style=text-align:center>3</td><td style=text-align:center>BeiJing</td><td style=text-align:center>Wang</td></tr><tr><td style=text-align:center>4</td><td style=text-align:center>HangZhou</td><td style=text-align:center>Liu</td></tr><tr><td style=text-align:center>5</td><td style=text-align:center>GuangZhou</td><td style=text-align:center>Li</td></tr></tbody></table><p>查询语句为：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> id, city, name
</span></span><span style=display:flex><span><span style=color:#66d9ef>FROM</span> t1
</span></span><span style=display:flex><span><span style=color:#66d9ef>ORDER</span> <span style=color:#66d9ef>BY</span> city <span style=color:#66d9ef>DESC</span>, name <span style=color:#66d9ef>ASC</span>;
</span></span></code></pre></div><p>使用方法 1 比较时，和传统的排序比较一样，两行数据比较时同时比较 city 和 name，如果 city 不同则比较结束，否则再比较 name。这样只需一轮排序便可以得到最终排序结果。算法如下图：</p><img src=/images/database/compare.png alt=image-20230416153439233 style=zoom:70%><p>注意图中两个关键词 <code>Branch</code> 和 <code>Pointer chasing</code>，正好对应这种比较算法的缺点：</p><ul><li>分支预测，降低 CPU 执行效率</li><li>内存随机访问效率低（相对顺序访问）</li></ul><p>使用方法 2 比较时，第一轮，先按 city 比较排序，结果如下：</p><table><thead><tr><th style=text-align:center>id</th><th style=text-align:center>city</th><th style=text-align:center>name</th></tr></thead><tbody><tr><td style=text-align:center>1</td><td style=text-align:center>BeiJing</td><td style=text-align:center>Zhang</td></tr><tr><td style=text-align:center>3</td><td style=text-align:center>BeiJing</td><td style=text-align:center>Wang</td></tr><tr><td style=text-align:center>2</td><td style=text-align:center>ChengDu</td><td style=text-align:center>Xie</td></tr><tr><td style=text-align:center>5</td><td style=text-align:center>GuangZhou</td><td style=text-align:center>Li</td></tr><tr><td style=text-align:center>4</td><td style=text-align:center>HangZhou</td><td style=text-align:center>Liu</td></tr></tbody></table><p>由于 city 有重复，只比较 city 不能得到最终排序结果，还需第二轮按照 name 比较排序，结果如下：</p><table><thead><tr><th style=text-align:center>id</th><th style=text-align:center>city</th><th style=text-align:center>name</th></tr></thead><tbody><tr><td style=text-align:center>3</td><td style=text-align:center>BeiJing</td><td style=text-align:center>Wang</td></tr><tr><td style=text-align:center>1</td><td style=text-align:center>BeiJing</td><td style=text-align:center>Zhang</td></tr><tr><td style=text-align:center>2</td><td style=text-align:center>ChengDu</td><td style=text-align:center>Xie</td></tr><tr><td style=text-align:center>5</td><td style=text-align:center>GuangZhou</td><td style=text-align:center>Li</td></tr><tr><td style=text-align:center>4</td><td style=text-align:center>HangZhou</td><td style=text-align:center>Liu</td></tr></tbody></table><p>可以看到，方法 2 每轮比较的字段一样，在数据重复较多时，会导致多轮排序。</p><h3 id=二进制字符串比较>二进制字符串比较</h3><p>二进制字符串比较技术通过简化比较器来提高排序性能。将 ORDER BY 子句中的所有列编码为单个二进制序列，当使用 memcmp 进行比较时将产生正确的排序顺序。对数据编码是有代价的，但由于在排序过程中大量使用比较器，因此付出这种代价是有价值的。让我们再看一下示例的 3 行：</p><table><thead><tr><th style=text-align:center>c_birth_country</th><th style=text-align:center>c_birth_year</th></tr></thead><tbody><tr><td style=text-align:center>NETHERLANDS</td><td style=text-align:center>1991</td></tr><tr><td style=text-align:center>NETHERLANDS</td><td style=text-align:center>1992</td></tr><tr><td style=text-align:center>GERMANY</td><td style=text-align:center>1924</td></tr></tbody></table><p>在little-endian硬件上，表示这些值的字节在内存中看起来像这样，假设 c_birth_year 为 32 位整数表示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>c_birth_country
</span></span><span style=display:flex><span>-- NETHERLANDS
</span></span><span style=display:flex><span>01001110 01000101 01010100 01001000 01000101 01010010 01001100 01000001 01001110 01000100 01010011 00000000
</span></span><span style=display:flex><span>-- GERMANY
</span></span><span style=display:flex><span>01000111 01000101 01010010 01001101 01000001 01001110 01011001 00000000
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>c_birth_year
</span></span><span style=display:flex><span>-- 1991
</span></span><span style=display:flex><span>11000111 00000111 00000000 00000000
</span></span><span style=display:flex><span>-- 1992
</span></span><span style=display:flex><span>11001000 00000111 00000000 00000000
</span></span><span style=display:flex><span>-- 1924
</span></span><span style=display:flex><span>10000100 00000111 00000000 00000000
</span></span></code></pre></div><p>那怎么将这些二进制编码为字符串才能满足需求呢？做法如下：</p><ul><li>固定二进制字符串大小，便于在排序过程中移动。不足大小的字符串以 00000000 填充，反之，如果字符串太大，只需要编码其前缀，只有当前缀相同时再比较整个字符串</li><li>降序字段的二进制取反（0变1，1变0），如示例中的 c_birth_country</li><li>升序排序字段的二进制按大端（高字节在地址，低字节在高地址，符合字符串处理顺序）编码表示，同时符号位（第一位）取反（1变0，0变1，保证负数的二进制字符串小于非负数）</li></ul><p>按上面的编码方式得到二进制字符串如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>-- NETHERLANDS | 1991
</span></span><span style=display:flex><span>10110001 10111010 10101011 10110111 10111010 10101101 10110011 10111110 10110001 10111011 10101100 11111111
</span></span><span style=display:flex><span>10000000 00000000 00000111 11000111
</span></span><span style=display:flex><span>-- NETHERLANDS | 1992
</span></span><span style=display:flex><span>10110001 10111010 10101011 10110111 10111010 10101101 10110011 10111110 10110001 10111011 10101100 11111111
</span></span><span style=display:flex><span>10000000 00000000 00000111 11001000
</span></span><span style=display:flex><span>-- GERMANY     | 1924
</span></span><span style=display:flex><span>10111000 10111010 10101101 10110010 10111110 10110001 10100110 11111111 11111111 11111111 11111111 11111111
</span></span><span style=display:flex><span>10000000 00000000 00000111 10000100
</span></span></code></pre></div><p>根据上面的规则生成二进制字符串后，现在可以通过只比较二进制字符串来同时比较两列。在 C++ 中使用单个 <code>memcmp</code> 函数即可完成比较，编译器将为单个函数调用生成高效的汇编，甚至自动生成 <code>SIMD</code> 指令（<strong>Why?</strong>）。</p><p>该技术解决了复杂比较带来的函数调用开销。</p><h3 id=基数排序>基数排序</h3><p>现在我们有了一个高效的比较器，我们得选择一个排序算法。计算机科学的同学都学习过基于比较的排序算法，例如 <code>Quicksort</code> 和 <code>Merge sort</code>，它们的时间复杂度为 \(O(nlogn)\)，其中 \(n\) 是要排序的记录数。</p><p>然而，也有基于分布的排序算法，它们的时间复杂度通常为 \(O(nk)\) 其中 \(k\) 是排序键的宽度。由于 \(k\) 是常数，而 \(logn\) 不是，因此这类排序算法在 \(n\) 越大的情况下越有优势。基于分布排序之一的算法是基数排序，该算法通过使用计数的方法计算数据分布从而实现对数据的排序，多次执行这种方法直到所有位都计算完毕。</p><p>对排序键列进行编码，这样我们就有了一个高效的比较器，然后选择一个基于分布而不是比较的排序算法，这听起来可能矛盾。然而，编码对于基数排序是必要的：使用 memcmp 比较二进制字符串将产生正确的顺序，那么如果我们逐字节进行基数排序也能产生正确的顺序。</p><blockquote><p>个人理解，如果使用基数排序，那么二进制字符串编码的主要目的是保证编码能够不改变原始比较的结果，且编码长度是固定位，也正好适用于基数排序。</p></blockquote><h3 id=两阶段并行排序>两阶段并行排序</h3><p>DuckDB 使用
<a href=https://15721.courses.cs.cmu.edu/spring2016/papers/p743-leis.pdf title="Morsel-Driven Parallelism" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Morsel-Driven Parallelism
<i class="fa fa-external-link-alt"></i>
</a>，这是一个用于并行查询执行的框架。对于排序操作，这意味着多个线程从表中并行收集大致相等数量的数据。</p><blockquote><p>推荐阅读论文 Morsel-Driven Parallelism 解读文章
<a href=https://zhuanlan.zhihu.com/p/378534053 title=https://zhuanlan.zhihu.com/p/378534053 rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://zhuanlan.zhihu.com/p/378534053
<i class="fa fa-external-link-alt"></i></a></p></blockquote><p>我们使用这种并行性进行排序，首先让每个线程使用基数排序对它收集的数据进行排序。在第一个排序阶段之后，每个线程都有一个或多个已排序的数据块，这些数据块必须合并得到最终的排序结果。归并排序是此任务的首选算法，归并排序的实现方式主要有两种：
<a href=https://en.wikipedia.org/wiki/K-way_merge_algorithm title="K-way merge" rel="noopener external nofollow noreferrer" target=_blank class=exturl>K-way merge
<i class="fa fa-external-link-alt"></i></a> and
<a href=https://en.wikipedia.org/wiki/Cascade_merge_sort title="Cascade merge" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Cascade merge
<i class="fa fa-external-link-alt"></i>
</a>.</p><p><em>K-way merge</em> 将 K 个列表一次合并为一个排序列表，并且常用于外部排序（对超过内存的数据进行排序），因为它最大限度地减少了 I/O。<em>Cascade merge</em> 一次合并两个已排序数据列表，直到只剩下一个已排序列表，用于内存排序，因为它比 <em>K-way merge</em> 更高效（<strong>思考这是为什么</strong>）。我们的目标是拥有一个具有高内存性能的实现，当我们超过可用内存的限制时，它会优雅地降级（<strong>这里降级指的什么？换成其他 Merge 算法？</strong>）。因此，我们选择 <em>Cascade merge</em>。</p><p>在 <em>Cascade merge sort</em> 中，我们一次合并两个已排序数据块，直到只剩下一个已排序数据块。自然地，我们希望使用所有可用的线程来计算合并。如果我们有比线程更多的排序块，我们可以让每个线程来合并块（<strong>每个线程都有活干</strong>）。然而，随着块的合并，我们将没有足够的块来保持所有线程忙碌（<strong>活少了，有些线程便会空闲</strong>）。当合并最后两个块时，这特别慢：一个线程必须处理所有数据。</p><p>为了完全并行化这一阶段，我们采用了 Oded Green 等人的
<a href=https://arxiv.org/pdf/1406.2628.pdf title="Merge Path" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Merge Path
<i class="fa fa-external-link-alt"></i>
</a>。<em>Merge Path</em> 会预先计算排序列表在合并时相交的位置，可以使用二分搜索有效地计算沿合并路径的交叉点。如果我们知道交叉点在哪里，我们就可以并行地独立合并排序数据的分区。这使我们能够在整个合并阶段有效地使用所有可用线程。</p><blockquote><p>Merge Path 这个技术点请阅读文章
<a href=https://zhuanlan.zhihu.com/p/606678298 title=https://zhuanlan.zhihu.com/p/606678298 rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://zhuanlan.zhihu.com/p/606678298
<i class="fa fa-external-link-alt"></i></a></p></blockquote><h3 id=列还是行>列还是行？</h3><p>除了比较之外，排序的另一大成本是移动数据。 DuckDB 有一个向量化的执行引擎。数据以列式布局存储，一次分批（称为 Chunks 块）处理。这种布局非常适合分析查询处理，因为块适合 CPU 缓存，并且它为编译器提供了很多生成 SIMD 指令的机会（<strong>列数据聚簇，可以同时处理</strong>）。然而当表被排序后，整行都会重新打乱排序，而不仅仅是参与排序的列。</p><p>我们可以在排序时坚持按列布局：对关键列进行排序，然后对 payload columns 一个一个重排序。但是，对每列重新排序将导致内存的随机访问。如果 payload 列很多，这会很慢。将列转换为行将使重新排序行变得更加容易。这种转换当然不是没有代价的：需要将列复制到行，并在排序后再次从行复制回列（<strong>数据本身是按列存储的，在排序的时候将列存转化为内存中的行存，排完后再转为列</strong>）。</p><p>因为我们想要支持外部排序，所以我们必须将数据存储在可以卸载到磁盘的缓冲区管理块中。因为无论如何我们都必须将输入数据复制到这些块中，所以将<strong>行转换为列</strong>实际上是没有额外代价的。</p><p>有一些运算符本质上是基于行的，例如连接和聚合。 DuckDB 对这些运算符有一个统一的内部行布局，我们决定也将它用于排序运算符。到目前为止，这种布局只在内存中使用过。在下一节中，将解释我们是如何让它在磁盘上工作的。应该注意，如果主内存无法容纳，我们只会将排序数据写入磁盘。</p><h3 id=外部排序>外部排序</h3><p>缓冲区管理器可以将块从内存卸载到磁盘。我们在排序实现中不会主动将内存块写入磁盘，而是由缓冲区管理器在内存填满时来触发。它使用 LRU 队列来决定哪些块将写入磁盘。</p><p>当需要一个块时，我们<code>固定(pin)</code>它，如果需要的块不在内存中，将会从磁盘读取它。访问磁盘比访问内存慢得多，因此尽量减少读写次数是至关重要的。</p><p>将数据卸载到磁盘对于固定大小的列（如整数）很容易，但对于可变大小的列（如字符串）则更难（<strong>Why</strong>）。我们的行布局使用固定大小的行，不能容纳任意大小的字符串。因此，字符串由一个指针表示，该指针指向实际字符串数据所在的特定内存块，即所谓的 “string heap”。</p><p>我们已经更改了堆，以便在缓冲区管理的块中也逐行存储字符串：</p><img src=/images/database/rowheap.jpg alt="最快的表排序 - 重新设计过 DuckDB 的排序" style=zoom:67%><p>每行都有一个额外的 8 字节字段指针，指向堆中该行的开头。这在内存表示中是无用的，但稍后我们将看到为什么它对磁盘表示有用。如果内存能放下数据，堆块将保持固定状态，并且在排序时仅对固定大小的行进行重新排序。如果内存放不下数据，则需要将块卸载到磁盘，并且堆在排序时也会重新排序。当堆块卸载到磁盘时，指向它的指针将失效。当我们将块加载回内存时，指针将会改变。</p><p>这就是我们的行式布局发挥作用的地方。 8 字节的指针字段被 8 字节的偏移量字段覆盖，表示在堆块中可以找到该行字符串的位置。这种技术称为
<a href=https://en.wikipedia.org/wiki/Pointer_swizzling title="“pointer swizzling”" rel="noopener external nofollow noreferrer" target=_blank class=exturl>“pointer swizzling”
<i class="fa fa-external-link-alt"></i>
</a>。当我们调整指针时，行布局和堆块看起来像这样：</p><p><img src=/imgs/img-lazy-loading.gif data-src=/images/database/heap_swizzled.jpg alt="最快的表排序 - 重新设计过 DuckDB 的排序"></p><p>指向后续字符串值的指针也被一个 8 字节的相对偏移量覆盖，表示该字符串距堆中行开头的偏移量（因此每个 stringA 的偏移量为 0：它是行中的第一个字符串）。在排序期间使用行内的相对偏移量而不是绝对偏移量非常有用，因为这些相对偏移量保持不变，并且在复制行时不需要更新。当需要扫描块以读取排序结果时，我们“unswizzle”指针，使它们再次指向字符串。</p><p>通过这种双重用途的按行表示，我们可以轻松地复制堆中固定大小的行和可变大小的行。除了让缓冲区管理器加载/卸载块之外，内存中排序和外部排序之间的唯一区别是我们 swizzle/unswizzle 指向堆块的指针，并在归并排序期间从堆块复制数据。</p><p>上述技术减少了由于内存不够带来的性能开销。</p><h3 id=comparison-with-other-systems>Comparison with Other Systems</h3><p>排序算法经过精心设计后，当然要和其他数据库管理系统比较才能证明 DuckDB 的性能优势，选取比较的系统如下：</p><ol><li><a href=https://clickhouse.tech/ title=ClickHouse rel="noopener external nofollow noreferrer" target=_blank class=exturl>ClickHouse
<i class="fa fa-external-link-alt"></i>
</a>, version 21.7.5</li><li><a href=https://hyper-db.de/ title=HyPer rel="noopener external nofollow noreferrer" target=_blank class=exturl>HyPer
<i class="fa fa-external-link-alt"></i>
</a>, version 2021.2.1.12564</li><li><a href=https://pandas.pydata.org/ title=Pandas rel="noopener external nofollow noreferrer" target=_blank class=exturl>Pandas
<i class="fa fa-external-link-alt"></i>
</a>, version 1.3.2</li><li><a href=https://www.sqlite.org/index.html title=SQLite rel="noopener external nofollow noreferrer" target=_blank class=exturl>SQLite
<i class="fa fa-external-link-alt"></i>
</a>, version 3.36.0</li></ol><p>比较结果就不贴了，可以直接看原文。</p><h4 id=结论>结论</h4><p>DuckDB 新的并行排序实现可以有效地对超出内存容量的数据进行排序，从而利用现代 SSD 的速度。在其他系统因为内存不足而崩溃或者切换到速度慢得多的外部排序算法的情况下，DuckDB 的性能在超过内存限制时优雅地下降（也就是说内存不足时，DuckDB 的性能下降得不是那么陡）。</p><h3 id=总结>总结</h3><p>本文翻译+总结了文章 《Fastest table sort in the West - Redesigning DuckDB’s sort》。这篇文章涉及的技术远不止排序，涉及了计算机中很多重要的基础知识，技术点比较细腻，需要扣细节并深入思考才能更好地理解。</p><h3 id=reference>Reference</h3><ul><li><a href="https://link.zhihu.com/?target=https%3A//duckdb.org/2021/08/27/external-sorting.html%23comparison-with-other-systems" title=https://duckdb.org/2021/08/27/external-sorting.html#comparison-with-other-systems rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://duckdb.org/2021/08/27/external-sorting.html#comparison-with-other-systems
<i class="fa fa-external-link-alt"></i></a></li><li><a href="https://link.zhihu.com/?target=https%3A//arxiv.org/pdf/1406.2628.pdf" title=https://arxiv.org/pdf/1406.2628.pdf rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://arxiv.org/pdf/1406.2628.pdf
<i class="fa fa-external-link-alt"></i></a></li><li><a href=https://zhuanlan.zhihu.com/p/606678298 title=https://zhuanlan.zhihu.com/p/606678298 rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://zhuanlan.zhihu.com/p/606678298
<i class="fa fa-external-link-alt"></i></a></li><li><a href="https://link.zhihu.com/?target=https%3A//15721.courses.cs.cmu.edu/spring2016/papers/p743-leis.pdf" title=https://15721.courses.cs.cmu.edu rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://15721.courses.cs.cmu.edu
<i class="fa fa-external-link-alt"></i></a></li></ul></div><footer class=post-footer><div class=post-tags><a href=/tags/radix-sort>radix sort</a>
<a href=/tags/merge-sort>merge sort</a>
<a href=/tags/database>database</a></div><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=post-copyright><img src=/imgs/cc/cc.svg width=75 height=75 align=right><ul><li class=post-copyright-title><strong>Post Title:</strong>
Fastest table sort in the West - Redesigning DuckDB’s sort</li><li class=post-copyright-author><strong>Post Author:</strong>
debuger</li><li class=post-copyright-link><strong>Post Link:</strong>
<a id=post-cr-link href=/post/2023-04-16-fastest-table-sort/ title="Fastest table sort in the West - Redesigning DuckDB’s sort">/post/2023-04-16-fastest-table-sort/</a></li><li class=post-copyright-license><strong>Copyright Notice:</strong>
All articles in this blog are licensed under <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh>BY-NC-SA</a> unless stating additionally.</li></ul></div><div class=followme><span>Welcome to my other publishing channels</span><div class=social-list><div class=social-item><a target=_blank class=social-link href=/images/wechat_channel.jpg><span class=icon><i class="fab fa-weixin"></i></span>
<span class=label>WeChat</span></a></div><div class=social-item><a target=_blank class=social-link href=/atom.xml><span class=icon><i class="fa fa-rss"></i></span>
<span class=label>RSS</span></a></div></div></div><div class=post-nav><div class="post-nav-next post-nav-item"></div><div class="post-nav-prev post-nav-item"><a href=/post/2023-03-23-radix-hash-join/ rel=prev title="Main-Memory Hash Joins on Multi-Core CPUs/ Tuning to the Underlying Hardware 论文解读">Main-Memory Hash Joins on Multi-Core CPUs/ Tuning to the Underlying Hardware 论文解读
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div id=comments class=post-comments><div class=comment-head><div class=comment-headline><i class="fas fa-comments fa-fw"></i>
<span>Comments</span></div></div><div class=comment-wrap><div><div class=comment-loading><i class="fa fa-sync fa-spin"></i></div><div class=giscus-container></div></div></div></div></div></main><footer class=footer><div class=footer-inner><div id=gtranslate class=google-translate><i class="fa fa-language"></i><div id=google_translate_element></div></div><div class=copyright>&copy;
<span itemprop=copyrightYear>2010 - 2023</span>
<span class=with-love><i class="fa fa-heart"></i></span>
<span class=author itemprop=copyrightHolder>debuger</span></div><div class=powered-by>Power by <a href=https://gohugo.io title=0.109.0 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.4.0 target=_blank>Hugo NexT.Gemini</a></div></div></footer><script type=text/javascript src=https://cdn.staticfile.org/animejs/3.2.1/anime.min.js defer></script>
<script type=text/javascript src=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.js defer></script>
<script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"busuanzi":{"pageview":true},"copybtn":true,"darkmode":false,"giscus":{"cfg":{"category":"Announcements","categoryid":"DIC_kwDOIqmyr84CTQGv","emit":false,"inputposition":"top","mapping":"title","reactions":true,"repo":"zhenyuxie/zhenyuxie.github.io","repoid":"R_kgDOIqmyrw","theme":"preferred_color_scheme"},"js":"https://giscus.app/client.js"},"hostname":"/","i18n":{"ds_day":" Day Ago","ds_days":" Day ","ds_hour":" Hour Ago","ds_hours":" Hour ","ds_just":"Just","ds_min":" Min Ago","ds_mins":" Min","ds_month":" Month Ago","ds_years":" Year ","empty":"We didn't find any results for the search: ${query}","hits":"","hits_time":"${hits} results found in ${time} ms","placeholder":"Searching..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":230},"statis":{"enable":true,"plugin":"busuanzi"},"vendor":{"plugins":"qiniu","router":"https://cdn.staticfile.org"},"version":"4.4.0","waline":{"cfg":{"comment":true,"emoji":false,"imguploader":false,"pageview":true,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o","reaction":true,"reactiontext":["点赞","得意"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"serverurl":"https://walinejs.comment.lithub.cc","sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"waline","file":"dist/waline.css","name":"@waline/client","version":"2.13.0"},"js":{"alias":"waline","file":"dist/waline.js","name":"@waline/client","version":"2.13.0"}}}</script><script type=text/javascript src=/js/main.min.37028fbafbd97fd89808b4c7b5a3a81f01ed0ab24001d273d774f9546a0e9170.js defer></script>
<script type=text/javascript src=/js/math.min.95d37ca8344f2f635c0f13f77cc75191efb6cdf99093ed73203a86e05f995fbb.js defer></script></body></html>