<!doctype html><html lang=zh-cn data-theme=light><head><meta charset=utf-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: light)"><meta name=generator content="Hugo 0.109.0"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_16x16_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_32_32_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="深入理解 Elasticsearch 分页技术"><meta itemprop=description content="Simple is the best."><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="/imgs/hugo_next_avatar.png"><meta itemprop=keywords content="Elasticsearch,分页"><meta property="og:type" content="article"><meta property="og:title" content="深入理解 Elasticsearch 分页技术"><meta property="og:description" content="Simple is the best."><meta property="og:image" content="/imgs/hugo_next_avatar.png"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="/post/2023-02-19-es-paginate/"><meta property="og:site_name" content="debuger"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="debuger"><meta property="article:published_time" content="2023-02-19 15:15:00 +0800 CST"><meta property="article:modified_time" content="2023-02-19 15:15:00 +0800 CST"><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/font-awesome/6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.css><link rel=stylesheet href=/css/main.min.42b65f4b5d8fdb26467483a54df0d4f1570d2f58db628dde5a9075d4ba6c423c.css><style type=text/css>.post-footer,.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":true,"isHome":false,"isPage":true,"math":{"js":{"file":"es5/tex-mml-chtml.js","name":"mathjax","version":"3.2.0"},"render":"mathjax"},"path":"2023-02-19-es-paginate","permalink":"/post/2023-02-19-es-paginate/","title":"深入理解 Elasticsearch 分页技术","waline":{"js":[{"alias":"waline","alias_name":"@waline/client","file":"dist/pageview.js","name":"pageview","version":"2.13.0"},{"alias":"waline","alias_name":"@waline/client","file":"dist/comment.js","name":"comment","version":"2.13.0"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>深入理解 Elasticsearch 分页技术 - debuger</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label="Toggle navigation bar" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>debuger</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>大道至简</p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about.html class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>技术博客
<span class=badge>18</span></a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>Search</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=Searching... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>TOC</li><li class=sidebar-nav-overview>Overview</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><ul><li><a href=#介绍>介绍</a></li><li><a href=#es-分页>ES 分页</a><ul><li><a href=#fromsize>From+Size</a></li><li><a href=#search-after>Search After</a></li><li><a href=#scroll>Scroll</a></li><li><a href=#小结>小结</a></li></ul></li><li><a href=#总结>总结</a></li><li><a href=#reference>Reference</a></li></ul></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=debuger src=/imgs/img-lazy-loading.gif data-src=/imgs/hugo_next_avatar.png><p class=site-author-name itemprop=name>debuger</p><div class=site-description itemprop=description>Simple is the best.</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>18</span>
<span class=site-state-item-name>Posts</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>13</span>
<span class=site-state-item-name>Categories</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>19</span>
<span class=site-state-item-name>Tags</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://www.zhihu.com/people/xzy-51-38 title="知乎 → https://www.zhihu.com/people/xzy-51-38" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-book fa-fw hvr-icon"></i>知乎</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title="Creative Commons"><img src=/imgs/img-lazy-loading.gif data-src=/imgs/cc/big/by_nc_sa.svg alt="Creative Commons"></a></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>Web Status</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>Running:</div><div class=item-count id=runTimes data-publishdate=2022-01-20T22:00:00+00:00></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>Visitors:</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>Views:</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>Words:</div><div class=item-count id=wordsCount data-count=50640></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>ReadTime:</div><div class=item-count id=readTimes data-times=112></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>Last Update:</div><div class=item-count id=last-push-date data-lastpushdate=2023-09-05T23:00:00+00:00></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-comments class="button goto-comments" title="Go to Comment"><i class="fas fa-comments"></i></div><div id=goto-gtranslate class=button title="Multilingual translation"><i class="fas fa-globe"></i></div><div id=toggle-theme class=button title="Change Theme"><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title="Back to Top"><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a>
<a href=https://github.com/debuger6 rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><script type=text/javascript src=//sidecar.gitter.im/dist/sidecar.v1.js async></script>
<script type=text/javascript>((window.gitter={}).chat={}).options={room:"hugo-next/community"}</script><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=/post/2023-02-19-es-paginate/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/hugo_next_avatar.png"><meta itemprop=name content="debuger"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="debuger"><meta itemprop=description content="Simple is the best."></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="深入理解 Elasticsearch 分页技术"><meta itemprop=description content="Elasticsearch 是一款分布式的搜索引擎，提供了灵活的分页技术。本文主要介绍 Elasticsearch（简称 ES） 的几种分页技术，并深入分析各种分页技术的优"></span><header class=post-header><h1 class=post-title itemprop="name headline">深入理解 Elasticsearch 分页技术</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i></span>
<span class=post-meta-item-text>Publish on:</span>
<time title="Publish on:2023-02-19 15:15:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2023-02-19 15:15:00 +0800 CST">2023-02-19</time></span>
<span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i></span>
<span class=post-meta-item-text>Classify at:</span>
<span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E itemprop=url rel=index><span itemprop=name>搜索引擎</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=Words><span class=post-meta-item-icon><i class="far fa-file-word"></i></span>
<span class=post-meta-item-text>Words:</span><span>4702</span></span>
<span class=post-meta-item title=Read><span class=post-meta-item-icon><i class="far fa-clock"></i></span>
<span class=post-meta-item-text>Read:&ap;</span>
<span>10min</span></span>
<span class=post-meta-item title=Views><span class=post-meta-item-icon><i class="far fa-eye"></i></span>
<span class=post-meta-item-text>Views:</span>
<span id=busuanzi_value_page_pv class=waline-pageview-count data-path=/post/2023-02-19-es-paginate/><i class="fa fa-sync fa-spin"></i></span></span>
<span class=post-meta-item title=Comments><span class=post-meta-item-icon><i class="far fa-comments"></i></span>
<span class=post-meta-item-text>Comments:</span>
<span class=waline-comment-count data-path=/post/2023-02-19-es-paginate/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><blockquote><p>Elasticsearch 是一款分布式的搜索引擎，提供了灵活的分页技术。本文主要介绍 Elasticsearch（简称 ES） 的几种分页技术，并深入分析各种分页技术的优缺点及应用场景。</p></blockquote><h3 id=介绍>介绍</h3><p>搜索引擎分页是指在搜索引擎中，将搜索结果分成多个页面展示，用户可以通过点击分页按钮或滚动页面来浏览不同页数的搜索结果。搜索引擎通常会在页面底部显示数字标记或其他标记以提示用户当前的位置和可用的页数。如下所示：</p><img src=/images/es/google-search1.png alt=image-20230219153516705 style=zoom:30%>
<img src=/images/es/google-search2.png alt=image-20230219153607405 style=zoom:30%><p>搜索引擎分页的目的是提高用户体验，让用户可以更轻松地从大量搜索结果中获取更精准的信息。当用户在搜索框中输入关键字并点击搜索按钮时，搜索引擎将返回与关键字相关的成千上万个搜索结果。如果将所有这些结果显示在一个页面上，页面加载时间会变得非常长，用户体验也会变得糟糕。因此，搜索引擎将搜索结果分页，相关度越高的结果越靠前，这样用户可以更快的找到想要的结果，同时减少页面加载时间和流量消耗。</p><p>本文主要关注分页技术，对于搜索引擎其他相关技术不在本文讨论范围，下面将介绍 ES 中的分页技术。</p><h3 id=es-分页>ES 分页</h3><p>在讲分页技术前，这里简单介绍下 ES 的查询流程，如图：</p><img src=/images/es/search.png alt=image-20230226151122477 style=zoom:50%><p>这里画的是最常见 Query_Then_Fetch 查询流程，整个步骤为：</p><ol><li><code>协调节点</code>接收查询请求</li><li><code>协调节点</code>转发 <code>QueryRequest</code> 请求给数据节点</li><li><code>数据节点</code>执行 <code>QueryPhrase</code>，查询满足条件的 <code>TopN</code> 文档信息（包括id、score，不包括文档内容）返回给协调节点</li><li><code>协调节点</code>接收到数据节点返回的 <code>QueryResults</code>，然后从 <code>k*TopN</code> 的文档信息中选出最终的 <code>TopN</code> 的结果</li><li><code>协调节点</code>发送 <code>FetchRequest</code> 给相关数据节点</li><li><code>数据节点</code>执行 <code>FetchPhrase</code>，根据文档id获取文档内容，然后返回给协调节点</li><li><code>协调节点</code>将最终的查询结果返回给客户端</li></ol><p>到这里，我们大体了解了 ES 的查询流程，下面来看下 ES 的分页技术。Elasticsearch 提供了三种分页技术：</p><ul><li><code>From+Size</code></li><li><code>Search After</code></li><li><code>Scroll</code></li></ul><p>下面详细介绍这三种分页技术并深入分析它们的实现原理。</p><h4 id=fromsize>From+Size</h4><h5 id=介绍-1>介绍</h5><p>在 ES 中，<code>from</code> 和 <code>size</code> 是两个控制分页查询的参数。<code>from</code> 参数用于指定从第几个文档开始返回结果，<code>size</code> 参数用于指定返回的结果集的大小。</p><p>具体来说，<code>from</code> 参数定义了结果集的起始点，而 <code>size</code> 参数定义了结果集的大小。如果想返回结果集中的前 10 个文档，可以将 <code>from</code> 参数设置为 0，<code>size</code> 参数设置为 10。</p><p>以下是一个使用 <code>from</code> 和 <code>size</code> 进行分页查询的示例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-Bash data-lang=Bash><span style=display:flex><span>GET /my_index/_search
</span></span><span style=display:flex><span><span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;from&#34;</span>: 100,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;size&#34;</span>: 10,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;query&#34;</span>: <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;match&#34;</span>: <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      <span style=color:#e6db74>&#34;content&#34;</span>: <span style=color:#e6db74>&#34;chatgpt&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>在这个示例中，我们将 <code>from</code> 参数设置为 100，<code>size</code> 参数设置为 10，以便返回结果集中 <code>[100,110)</code> 共 10 个匹配 <code>content</code> 字段的文档，相当于返回第 11 页的结果集。那是不是我们可以在任何分页场景下都可以使用这种分页方式呢，答案是否定的，ES 对<code> from+size</code> 是有限制的，默认值为 10000。</p><p>那问题来了，为什么会有这样的限制呢？这个问题也是本文的重点之一。ES 官方文档给出的解释是：对于深度分页，ES 的每个 shard 都会查询 TopN（查询流程的步骤3，注意 <code>N=from+size</code>）的结果，即查询 <code>[from, from+size)</code> 的结果实际上数据节点会查询 <code>from+size</code> 个结果，也就是将 <code>[0, from)</code> 的结果也一并查出来了，这样将会导致 CPU 和 内存的开销较大，导致系统卡顿甚至 OOM（特别是协调节点，要收集多个 shard 返回的结果，内存开销更大）。因此，<code>from+size</code> 常常应用于分页深度较小的场景，不适合深分页场景。</p><p>好了，那问题又来了，明明只查询 size 个结果，为什么每个 shard 偏要将 <code>[0, from+size)</code> 的结果都查出来呢，直接返回 <code>[from, from+size]</code> 的结果不就完了吗？要回答这个问题，首先要来看个简单的例子，如下：</p><img src=/images/es/search-demo1.png alt=image-20230219213014958 style=zoom:50%><p>如上图，假设有 3 个shard，每个 shard 的文档按照 <code>value</code> 字段大笑逆序排序，查询的 <code>from</code> 设置为 2，<code>size</code> 设置为 3。那么按照 ES 的处理逻辑，每个 shard 都会返回 <code>[0, 5)</code> 的文档（注意不包含文档内容），协调节点将收到 15 条文档，然后对这 15 条文档按照 <code>value</code> 排序，取前 [2, 5) 的文档为结果。如上图的 <code>result</code> 即为正确结果。</p><p>那么如果每个 shard 只返回各自的 [2, 5) 的文档，结果将会如何呢？请看下图：</p><img src=/images/es/search-demo2.png alt=image-20230219214834820 style=zoom:50%><p>上图表示每个 shard 返回 <code>[2, 5)</code> 的文档集合并后的结果。很明显，这个结果是不正确的，原因便是每个 shard 并不知道全局的排序结果，因此为了保证能够得到正确的结果，必须返回 <code>[0, 5]</code> 的结果集，因为它们中的任意一个都可能在全局序的 <code>[2, 5）</code> 范围内。</p><h5 id=实现原理>实现原理</h5><p>上一节介绍了 <code>from+size</code> 的用法和基本原理，这一节来分析下 <code>from+size</code> 在 ES 中是如何实现的，只有真正明白了实现原理，才能更好地掌握使用。下面分几种情况讨论：</p><ul><li>不打分场景（打分的特殊场景，打分为常量）</li><li>打分场景</li><li>排序场景</li></ul><p>第一种情况<code>不打分场景</code>， DSL 如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;from&#34;</span>: <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;size&#34;</span>: <span style=color:#ae81ff>5</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;query&#34;</span>: { <span style=color:#75715e>// 这里如果没有 query 其实也相当于不打分，因为每个 doc 的打分都是常量 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>&#34;bool&#34;</span>: {
</span></span><span style=display:flex><span>      <span style=color:#f92672>&#34;filter&#34;</span>: [ <span style=color:#75715e>// filter 查询不打分
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        {
</span></span><span style=display:flex><span>          <span style=color:#f92672>&#34;term&#34;</span>: {
</span></span><span style=display:flex><span>            <span style=color:#f92672>&#34;clientip.keyword&#34;</span>: <span style=color:#e6db74>&#34;110.47.202.158&#34;</span>
</span></span><span style=display:flex><span>          }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>      ]
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我们来看下上述 DSL 执行的关键流程，为了便于说明，引用部分源码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// ContextIndexSearcher.java 该类继承自 lucene 的 IndexSearcher 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>search</span><span style=color:#f92672>(</span>List<span style=color:#f92672>&lt;</span>LeafReaderContext<span style=color:#f92672>&gt;</span> leaves<span style=color:#f92672>,</span> Weight weight<span style=color:#f92672>,</span> Collector collector<span style=color:#f92672>)</span> <span style=color:#66d9ef>throws</span> IOException <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span>LeafReaderContext ctx <span style=color:#f92672>:</span> leaves<span style=color:#f92672>)</span> <span style=color:#f92672>{</span> <span style=color:#75715e>// search each subreader
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        searchLeaf<span style=color:#f92672>(</span>ctx<span style=color:#f92672>,</span> weight<span style=color:#f92672>,</span> collector<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>leaves 代表 lucene 的 segment，在该方法中会遍历查询每个 segment。本文的重点不是源码解析，这里只贴少量代码，我们直接看查询 segment 的关键代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// DefaultBulkScorer.scoreRange 方法部分代码
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>while</span> <span style=color:#f92672>(</span>currentDoc <span style=color:#f92672>&lt;</span> end<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>acceptDocs <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span> acceptDocs<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>currentDoc<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    	collector<span style=color:#f92672>.</span><span style=color:#a6e22e>collect</span><span style=color:#f92672>(</span>currentDoc<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    currentDoc <span style=color:#f92672>=</span> iterator<span style=color:#f92672>.</span><span style=color:#a6e22e>nextDoc</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>这里开始遍历 segment 中的 doc，然后用 collector(shard级，所有segment共用) 取收割 doc，这里的 collector 实际是 <code>SimpleTopScoreDocCollector</code>.getLeafCollector 获取的匿名类对象。collector.collect 的逻辑如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>collect</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> doc<span style=color:#f92672>)</span> <span style=color:#66d9ef>throws</span> IOException <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> score <span style=color:#f92672>=</span> scorer<span style=color:#f92672>.</span><span style=color:#a6e22e>score</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    totalHits<span style=color:#f92672>++;</span>
</span></span><span style=display:flex><span>    hitsThresholdChecker<span style=color:#f92672>.</span><span style=color:#a6e22e>incrementHitCount</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>minScoreAcc <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>(</span>totalHits <span style=color:#f92672>&amp;</span> minScoreAcc<span style=color:#f92672>.</span><span style=color:#a6e22e>modInterval</span><span style=color:#f92672>)</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      updateGlobalMinCompetitiveScore<span style=color:#f92672>(</span>scorer<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// pqTop 的doc和score初始为&lt;2147483647, 负无穷&gt;，只有当pq满后，才会将其挤出去
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>score <span style=color:#f92672>&lt;=</span> pqTop<span style=color:#f92672>.</span><span style=color:#a6e22e>score</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span> 
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>totalHitsRelation <span style=color:#f92672>==</span> TotalHits<span style=color:#f92672>.</span><span style=color:#a6e22e>Relation</span><span style=color:#f92672>.</span><span style=color:#a6e22e>EQUAL_TO</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        updateMinCompetitiveScore<span style=color:#f92672>(</span>scorer<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>  	<span style=color:#75715e>// 把 doc 加入 pqTop
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    pqTop<span style=color:#f92672>.</span><span style=color:#a6e22e>doc</span> <span style=color:#f92672>=</span> doc <span style=color:#f92672>+</span> docBase<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    pqTop<span style=color:#f92672>.</span><span style=color:#a6e22e>score</span> <span style=color:#f92672>=</span> score<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    pqTop <span style=color:#f92672>=</span> pq<span style=color:#f92672>.</span><span style=color:#a6e22e>updateTop</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 关键，更新文档所需最小的 score
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    updateMinCompetitiveScore<span style=color:#f92672>(</span>scorer<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span></code></pre></div><blockquote><p>所有 collector 都会维护一个<strong>堆 pq</strong> 来收集 topN 的 doc</p></blockquote><p>这里关注下方法 updateMinCompetitiveScore，<code>当 pq 满</code>，下一个 doc 进来会走到第 14 行，里面会更新所需 doc 的最小 score 值为大于 pqTop.score 的第一个 float 值，而且由于是不打分场景，所以还会调用 DocIdSetIterator.empty 重新生成一个 iterator，这个 iterator 的 nextDoc 方法永远只返回一个常量 NO_MORE_DOCS(2147483647)，因此外层 while 继续遍历时将终止循序。如果当前 segment 遍历完毕后，pq 还没满，那么将继续查询下一个 segment。</p><p>好了，如果查询完当前 segment，pq 已经满了，那剩下的 segment 还需要继续遍历吗？答案是否定的，原因是，查询下一个 segment 时，调用 collector.setScorer 内部会调用 updateMinCompetitiveScore 生成一个永远只返回 NO_MORE_DOCS 的 DocIdSetIterator，因此，scoreRange 里面的 while 循环永远走不进去。</p><p>通过上述的分析，<code>from+size</code> 在这种不打分的场景下，性能是最好的。</p><p>第二种情况<code>打分场景</code>，DSL 如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>GET</span> <span style=color:#960050;background-color:#1e0010>kibana_sample_data_logs_</span><span style=color:#ae81ff>1</span><span style=color:#960050;background-color:#1e0010>/_search</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;from&#34;</span>: <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;size&#34;</span>: <span style=color:#ae81ff>5</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;query&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;match&#34;</span>: {
</span></span><span style=display:flex><span>      <span style=color:#f92672>&#34;message&#34;</span>: <span style=color:#e6db74>&#34;GET&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这种场景也是使用 <code>SimpleTopScoreDocCollector</code> 来收割 doc，所以也是走的第一种情况的 collect 方法，不同的是，当 pq 满后，还会继续遍历 doc，因为后面可能还有 doc 的 score 大于 pqTop.score。因此，打分场景需要遍历完所有 segment 的所有 doc 才能确定最终的结果。不难看出，该场景的性能会比上一种场景性能差，所以，如果没有打分需求，应该避免使用打分的 query 语句。</p><p>第三种场景<code>排序场景</code>，DSL 如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>GET</span> <span style=color:#960050;background-color:#1e0010>kibana_sample_data_logs_</span><span style=color:#ae81ff>1</span><span style=color:#960050;background-color:#1e0010>/_search</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;from&#34;</span>: <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;size&#34;</span>: <span style=color:#ae81ff>5</span>,
</span></span><span style=display:flex><span>  <span style=color:#75715e>// query（打分或不打分） 省略
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#f92672>&#34;sort&#34;</span>: [
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:#f92672>&#34;bytes&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:#f92672>&#34;order&#34;</span>: <span style=color:#e6db74>&#34;desc&#34;</span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>查询时指定了排序字段，那么便需要按排序字段的顺序返回 topN 的结果。这种场景会使用 <code>SimpleFieldCollector</code> 来收割 doc，代码太长，这里不贴代码了，collect 的逻辑和上面场景类似，不同的是比较当前 doc 和 pqTop 时，比较的是排序字段的 docValue。</p><p>如果文档写入时不是按查询时的排序字段排序的，那么将会遍历完 shard 的所有 doc 才能得到最终结果。反之，如果文档本来是按排序字段排序的，那么查询时 collect 里面有个优化分支，当 pq 满后，会触发提前终止，裁剪掉当前 segment 剩下的 doc，查询后面的 segment 时，逻辑一样。</p><h4 id=search-after>Search After</h4><h5 id=介绍-2>介绍</h5><p>上一小节介绍了 <code>from+size</code> 的原理，也分析了它的弊端 - 即不适合深分页。好了，如果我们需要获取前 1000 页，每页 10 条文档怎么办？针对这种深分页场景，ES 提供了一种新的分页方式 – <code>search_after</code>。Elasticsearch 中的 <code>search_after</code> 机制是一种更有效的分页方法，它可以在不加载整个数据集的情况下快速地获取下一页数据。</p><p><code>search_after</code> 是一种基于游标的分页方法，使用 <code>search_after</code> 查询时必须指定排序字段（可以有多个），它<strong>使用排序字段值作为游标</strong>，从而能够更快地获取下一页的数据。在进行第一次搜索时，ES 会返回第一页的结果，当需要获取下一页数据时，可以使用上一页最后一个文档的排序字段值作为游标进行搜索。通过这种方式，可以逐步遍历整个数据集而无需一次性加载所有数据。</p><p>使用 <code>search_after</code> 机制需要注意以下几点：</p><ol><li>搜索请求必须指定排序字段，用于指定搜索结果的顺序</li><li>搜索第一页不必指定 <code>search_after</code> 参数，从第二页开始必须指定 <code>search_after</code> 为上一页的最后一个游标</li><li>游标必须是<strong>唯一</strong>的，否则可能会出现重复的数据</li></ol><p><code>search_after</code> 用法举例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>GET</span> <span style=color:#960050;background-color:#1e0010>twitter/_search</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;query&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:#f92672>&#34;match&#34;</span>: {
</span></span><span style=display:flex><span>            <span style=color:#f92672>&#34;title&#34;</span>: <span style=color:#e6db74>&#34;elasticsearch&#34;</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;sort&#34;</span>: [
</span></span><span style=display:flex><span>        {<span style=color:#f92672>&#34;date&#34;</span>: <span style=color:#e6db74>&#34;asc&#34;</span>},
</span></span><span style=display:flex><span>        {<span style=color:#f92672>&#34;tie_breaker_id&#34;</span>: <span style=color:#e6db74>&#34;asc&#34;</span>}      
</span></span><span style=display:flex><span>    ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>tie_breaker_id 是 _id 的拷贝，开启 doc_values 用于排序</p></blockquote><p>tie_breaker_id 的目的是保证游标的唯一性，继续搜索下一页：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>GET</span> <span style=color:#960050;background-color:#1e0010>twitter/_search</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;query&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:#f92672>&#34;match&#34;</span>: {
</span></span><span style=display:flex><span>            <span style=color:#f92672>&#34;title&#34;</span>: <span style=color:#e6db74>&#34;elasticsearch&#34;</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;search_after&#34;</span>: [<span style=color:#ae81ff>1463538857</span>, <span style=color:#e6db74>&#34;654323&#34;</span>], <span style=color:#75715e>// 上一页最后一个排序字段的值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>&#34;sort&#34;</span>: [
</span></span><span style=display:flex><span>        {<span style=color:#f92672>&#34;date&#34;</span>: <span style=color:#e6db74>&#34;asc&#34;</span>},
</span></span><span style=display:flex><span>        {<span style=color:#f92672>&#34;tie_breaker_id&#34;</span>: <span style=color:#e6db74>&#34;asc&#34;</span>}
</span></span><span style=display:flex><span>    ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可以看到，<code>search_after</code> 的使用特别灵活，只要指定了游标值，便能根据游标值查询下一页文档。由于查询过程中，可能还会有数据写入，那么多次查询使用一个游标可能得到的结果不一致，如果业务有一致性需求，需要使用 <code>point in time(PIT)</code> 来创建一个临时的快照，查询时使用该快照保证数据一致性。</p><h5 id=实现原理-1>实现原理</h5><p><code>search_after</code> 使用 <code>PagingFieldCollector</code> 来收割 doc，原理和 <code>from+size</code> 的第三种情况类似，收割<code>从 doc 0 开始</code>，不同的是，collect 时会多一次过滤，即会比较当前 doc 的排序字段值和 search_after 值的大小，如果不满足条件则直接过滤掉，也就意味着 pq 操作更少。因此，整体来看性能会更好。</p><p>当然，如果写入的数据已按排序字段排序，那么当 pq 满后，会走优化分支触发提前终止，裁剪掉当前 segment 剩下的 doc。</p><h4 id=scroll>Scroll</h4><h5 id=介绍-3>介绍</h5><p>上一节讲了 <code>search_after</code> 可以用来做深分页，ES 还提供了一种分页技术 – <code>Scroll</code> 查询，<code>Scroll</code> 查询是一种在 ES 中扫描大量数据的常用方法。它通过在搜索结果中建立一个保持状态的 <code>scroll_id</code> 来实现。当您开始滚动时，ES 会返回第一批结果，并返回一个保持状态的 ID。使用此 ID，可以执行下一个滚动请求，以检索下一批结果。此过程可以重复进行，直到所有数据都被扫描完毕为止。</p><p><code>Scoll</code> 查询的使用例子如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>POST</span> <span style=color:#960050;background-color:#1e0010>/my-index</span><span style=color:#ae81ff>-000001</span><span style=color:#960050;background-color:#1e0010>/_search?scroll=</span><span style=color:#ae81ff>1</span><span style=color:#960050;background-color:#1e0010>m</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;size&#34;</span>: <span style=color:#ae81ff>100</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;query&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;match&#34;</span>: {
</span></span><span style=display:flex><span>      <span style=color:#f92672>&#34;message&#34;</span>: <span style=color:#e6db74>&#34;foo&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>第一次查询要指定 scroll 参数，参数值代表 scroll 上下文的保留时长，保留时间过期后，scroll_id 将失效。接着继续查询下一批数据：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>POST</span> <span style=color:#960050;background-color:#1e0010>/_search/scroll</span>                                                               
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;scroll&#34;</span> : <span style=color:#e6db74>&#34;1m&#34;</span>,                                                                 
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;scroll_id&#34;</span> : <span style=color:#e6db74>&#34;DXF1ZXJ5QW5kRmV0Y2gBAAAAAAAAAD4WYm9laVYtZndUQlNsdDcwakFMNjU1QQ==&#34;</span> 
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>scroll 的用法很简单，除了第一次查询，后面的查询每次传入 scroll_id 便可以拉取下一页数据。由此可以看出，scroll 只能顺序往下翻页，不能往回翻。</p><h5 id=实现原理-2>实现原理</h5><p>分三种情况讨论：</p><ol><li>不带 query，不带 sort</li><li>带 query，不带 sort</li><li>带 sort</li></ol><blockquote><p>Scroll 查询会保留一个上下文 ScrollContext，上下文中包含了快照信息和上一页文档信息。</p></blockquote><p>第一种情况其实就是将全量数据按存储顺序往后翻页，这种情况使用 <code>PagingTopScoreDocCollector</code> 来收割 doc，特殊的是收割的 doc 不再时从 0 开始，而是从上一页最后一个 <code>doc+1 开始</code>，往后收割 size 个 doc 即完成本次 scoll。由此可以看出，对于这种情况，查询效率非常高。</p><p>第二种情况会使用 <code>PagingTopScoreDocCollector</code> 来收割 doc，<code>收割从 doc 0 开始</code>，由于 Scroll 上下文保存了上一页 doc 信息（pq中存储了上一页的doc），会过滤掉分数低于 pqTop 的 doc（如果当前 doc 分数和 pqTop 分数相同，则比较 doc 值）。</p><p>第三种情况会使用 <code>PagingFieldCollector</code> 来收割 doc，<code>收割从 doc 0 开始</code>，收割的逻辑和 search_after 类似，collect 时会比较上一页最后一个 doc 的排序字段值，如果不满足条件则过滤掉当前 doc。</p><h4 id=小结>小结</h4><p>这节介绍了三种分页方式的概念和原理，可以得出下面结论：</p><ul><li><code>from+size</code> 适合翻页灵活且页数不大的场景，即适合浅分页场景</li><li><code>search_after</code> 适合深分页，也可以来回翻页（需要业务存储每页所需的search_after）</li><li><code>scroll</code> 可以做分页，但是只能顺序往后翻页，不够灵活。所以它最适合做大量数据的导出（对顺序无要求，scan完所有数据即可）</li></ul><h3 id=总结>总结</h3><p>本文主要介绍了 Elasticsearch 中三种分页方式的概念，并详细分析了它们各自的实现原理，最后分析了它们各自适合的使用场景。</p><h3 id=reference>Reference</h3><ul><li><a href=https://www.elastic.co/guide/en/elasticsearch/reference/current/paginate-search-results.html#paginate-search-results title=https://www.elastic.co/guide/en/elasticsearch/reference/current/paginate-search-results.html#paginate-search-results rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://www.elastic.co/guide/en/elasticsearch/reference/current/paginate-search-results.html#paginate-search-results
<i class="fa fa-external-link-alt"></i></a></li></ul></div><footer class=post-footer><div class=post-tags><a href=/tags/elasticsearch>Elasticsearch</a>
<a href=/tags/%e5%88%86%e9%a1%b5>分页</a></div><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=post-copyright><img src=/imgs/cc/cc.svg width=75 height=75 align=right><ul><li class=post-copyright-title><strong>Post Title:</strong>
深入理解 Elasticsearch 分页技术</li><li class=post-copyright-author><strong>Post Author:</strong>
debuger</li><li class=post-copyright-link><strong>Post Link:</strong>
<a id=post-cr-link href=/post/2023-02-19-es-paginate/ title="深入理解 Elasticsearch 分页技术">/post/2023-02-19-es-paginate/</a></li><li class=post-copyright-license><strong>Copyright Notice:</strong>
All articles in this blog are licensed under <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh>BY-NC-SA</a> unless stating additionally.</li></ul></div><div class=followme><span>Welcome to my other publishing channels</span><div class=social-list><div class=social-item><a target=_blank class=social-link href=/images/wechat_channel.jpg><span class=icon><i class="fab fa-weixin"></i></span>
<span class=label>WeChat</span></a></div><div class=social-item><a target=_blank class=social-link href=/atom.xml><span class=icon><i class="fa fa-rss"></i></span>
<span class=label>RSS</span></a></div></div></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/post/2023-03-23-radix-hash-join/ rel=next title="Main-Memory Hash Joins on Multi-Core CPUs/ Tuning to the Underlying Hardware 论文解读"><i class="fa fa-chevron-left"></i> Main-Memory Hash Joins on Multi-Core CPUs/ Tuning to the Underlying Hardware 论文解读</a></div><div class="post-nav-prev post-nav-item"><a href=/post/2023-02-15-merge_path/ rel=prev title="Merge Path - A Visually Intuitive Approach to Parallel Merging 论文解读">Merge Path - A Visually Intuitive Approach to Parallel Merging 论文解读
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div id=comments class=post-comments><div class=comment-head><div class=comment-headline><i class="fas fa-comments fa-fw"></i>
<span>Comments</span></div></div><div class=comment-wrap><div><div class=comment-loading><i class="fa fa-sync fa-spin"></i></div><div class=giscus-container></div></div></div></div></div></main><footer class=footer><div class=footer-inner><div id=gtranslate class=google-translate><i class="fa fa-language"></i><div id=google_translate_element></div></div><div class=copyright>&copy;
<span itemprop=copyrightYear>2010 - 2023</span>
<span class=with-love><i class="fa fa-heart"></i></span>
<span class=author itemprop=copyrightHolder>debuger</span></div><div class=powered-by>Power by <a href=https://gohugo.io title=0.109.0 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.4.0 target=_blank>Hugo NexT.Gemini</a></div></div></footer><script type=text/javascript src=https://cdn.staticfile.org/animejs/3.2.1/anime.min.js defer></script>
<script type=text/javascript src=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.js defer></script>
<script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"busuanzi":{"pageview":true},"copybtn":true,"darkmode":false,"giscus":{"cfg":{"category":"Announcements","categoryid":"DIC_kwDOIqmyr84CTQGv","emit":false,"inputposition":"top","mapping":"title","reactions":true,"repo":"debuger6/zhenyuxie.github.io","repoid":"R_kgDOIqmyrw","theme":"preferred_color_scheme"},"js":"https://giscus.app/client.js"},"hostname":"/","i18n":{"ds_day":" Day Ago","ds_days":" Day ","ds_hour":" Hour Ago","ds_hours":" Hour ","ds_just":"Just","ds_min":" Min Ago","ds_mins":" Min","ds_month":" Month Ago","ds_years":" Year ","empty":"We didn't find any results for the search: ${query}","hits":"","hits_time":"${hits} results found in ${time} ms","placeholder":"Searching..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":230},"statis":{"enable":true,"plugin":"busuanzi"},"vendor":{"plugins":"qiniu","router":"https://cdn.staticfile.org"},"version":"4.4.0","waline":{"cfg":{"comment":true,"emoji":false,"imguploader":false,"pageview":true,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o","reaction":true,"reactiontext":["点赞","得意"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"serverurl":"https://walinejs.comment.lithub.cc","sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"waline","file":"dist/waline.css","name":"@waline/client","version":"2.13.0"},"js":{"alias":"waline","file":"dist/waline.js","name":"@waline/client","version":"2.13.0"}}}</script><script type=text/javascript src=/js/main.min.37028fbafbd97fd89808b4c7b5a3a81f01ed0ab24001d273d774f9546a0e9170.js defer></script>
<script type=text/javascript src=/js/math.min.95d37ca8344f2f635c0f13f77cc75191efb6cdf99093ed73203a86e05f995fbb.js defer></script></body></html>