<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>debuger</title><link>/</link><description>Recent content on debuger</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Thu, 23 Mar 2023 23:00:00 +0800</lastBuildDate><atom:link href="/rss.xml" rel="self" type="application/rss+xml"/><item><title>Main-Memory Hash Joins on Multi-Core CPUs/ Tuning to the Underlying Hardware 论文解读</title><link>/post/2023-03-23-radix-hash-join/</link><pubDate>Thu, 23 Mar 2023 23:00:00 +0800</pubDate><guid>/post/2023-03-23-radix-hash-join/</guid><description>这篇论文介绍了如何在多核 CPU 上结合底层硬件参数（能力）调优 Main-Memory Hash Joins 算法。 介绍 hash join 是一种常见的数据库操作，用于将两个表中的行通过一个共同的 join 键连接</description></item><item><title>深入理解 Elasticsearch 分页技术</title><link>/post/2023-02-19-es-paginate/</link><pubDate>Sun, 19 Feb 2023 15:15:00 +0800</pubDate><guid>/post/2023-02-19-es-paginate/</guid><description>Elasticsearch 是一款分布式的搜索引擎，提供了灵活的分页技术。本文主要介绍 Elasticsearch（简称 ES） 的几种分页技术，并深入分析各种分页技术的优</description></item><item><title>关于我</title><link>/about.html</link><pubDate>Sat, 18 Feb 2023 22:00:00 +0800</pubDate><guid>/about.html</guid><description>“上士闻道，勤而行之；中士闻道，若存若亡；下士闻道，大笑之。不笑不足以为道。” —《道德经》 debuger, 热爱技术，乐于分享、学习，主要专注于数据库内核、</description></item><item><title>Merge Path - A Visually Intuitive Approach to Parallel Merging 论文解读</title><link>/post/2023-02-15-merge_path/</link><pubDate>Wed, 15 Feb 2023 22:00:00 +0800</pubDate><guid>/post/2023-02-15-merge_path/</guid><description>在看DuckDB技术博客时，了解到这篇论文。文章提出的算法非常实用，在工程实践中应用效果也很好。本文主要对论文核心部分进行解读，并会根据自己</description></item><item><title>lucene 编码技术 - DirectMonotonicWriter</title><link>/2022/12/13/lucene-dmw/</link><pubDate>Sun, 18 Dec 2022 17:13:00 +0000</pubDate><guid>/2022/12/13/lucene-dmw/</guid><description>从名称可以看出，DirectMonotonicWriter 这个类主要是针对单调递增或者递减（即有序）数据集的编码。本文将结合源码分析其编码原</description></item><item><title>lucene 编码技术 - DirectWriter</title><link>/2022/12/04/lucene-dw/</link><pubDate>Sun, 04 Dec 2022 10:56:00 +0000</pubDate><guid>/2022/12/04/lucene-dw/</guid><description>DirectWriter 这个类的主要作用是将 long[] 型数据集编码存储到 byte[] 中，其实现充分考虑压缩比和性能因素。 编码原理 DirectWriter 使用的是固定位编码方式，即数据集中的所有元数均按照</description></item><item><title>Pebble 源码剖析 - Skiplist</title><link>/2022/02/26/pebble-skiplist/</link><pubDate>Sat, 26 Feb 2022 23:27:00 +0000</pubDate><guid>/2022/02/26/pebble-skiplist/</guid><description>本章主要从源码角度来分析 Pebble 对 Skiplist（跳表）的高性能设计，对于跳表的介绍及原理可以参考 百科 或网上其他文章，本文不做冗余介绍。 数据结构</description></item><item><title>Pebble 源码剖析-写入流程(续)</title><link>/2022/01/24/pebble-write-s/</link><pubDate>Wed, 16 Feb 2022 23:26:00 +0000</pubDate><guid>/2022/01/24/pebble-write-s/</guid><description>上一章，分析了 Pebble 写入的整体流程，并深入分析了 Pipeline 的三个执行阶段。但还未对 large batch 和 makeRoomForWrite 具体执行逻辑进行分析，本章将对这两点内容展开讨论。 Large Batch 这里首先</description></item><item><title>Compaction 策略 - Leveled</title><link>/2022/01/30/compaction-leveled/</link><pubDate>Sun, 30 Jan 2022 22:58:00 +0000</pubDate><guid>/2022/01/30/compaction-leveled/</guid><description>在上一章，我们介绍了 Size-Tiered Compaction 策略（STCS），讨论了 STCS 的原理，并着重分析了它的缺陷 &amp;ndash; 空间放大。本章我们将会介绍另一种策略 &amp;ndash; Level Compaction Strategy (LCS)，该策</description></item><item><title>Compaction 策略 - Size-Tiered</title><link>/2022/01/27/compaction-size-tired/</link><pubDate>Thu, 27 Jan 2022 23:58:00 +0000</pubDate><guid>/2022/01/27/compaction-size-tired/</guid><description>开篇 本系列文章主要介绍 LSM-Tree 中非常重要的技术点 &amp;ndash; Compaction。理解 Compaction 的作用及工作机制，对基于 LSM-Tree 类型的数据库开发或者调优有极大的益处。本系</description></item><item><title>Pebble 源码剖析-写入流程</title><link>/2022/01/24/pebble-write/</link><pubDate>Mon, 24 Jan 2022 00:00:04 +0000</pubDate><guid>/2022/01/24/pebble-write/</guid><description>本章会结合 Pebble 源码来剖析整个写入流程，并会深入分析整个写入路径上涉及的一些技术细节。这里说明，文章只会贴一些关键代码和代码行数较少的函数或者方</description></item><item><title>初识Pebble</title><link>/2022/01/20/pebble-intr/</link><pubDate>Thu, 20 Jan 2022 22:00:00 +0000</pubDate><guid>/2022/01/20/pebble-intr/</guid><description>Pebble 来源 Pebble 是 Cockroach 参考 RocksDB 并用 Go 语言开发的高性能 KV 存储引擎。一直以来 CockroachDB 以 RocksDB 作为底层存储引擎，虽然 RocksDB 是一款非常优秀的 KV 内嵌式数据库，但是在 Cockroach 的使用过程</description></item><item><title/><link>/elasticsearch-%E8%81%9A%E5%90%88%E6%9F%A5%E8%AF%A2%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/elasticsearch-%E8%81%9A%E5%90%88%E6%9F%A5%E8%AF%A2%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/</guid><description> Elasticsearch是一个高性能、可伸缩的分布式全文搜索和分析引擎，支持聚合查询功能。聚合查询是一种将搜索结果进行分组并计算聚合度量的方法，可以实现统计分析、数据挖掘等复杂查询需求。本文将剖析Elasticsearch聚合查询的原理。
聚合查询的基本概念 在 Elasticsearch 中，聚合查询是由聚合器（Aggregator）构成的。聚合器是一种计算文档集合中某些属性的统计信息的组件。它们可以嵌套在一起形成复杂的聚合查询。聚合查询的结果可以作为一个或多个值返回给用户，也可以作为一个或多个分桶（Bucket）返回给用户。分桶是一种将文档按照某些属性进行分组的方法。每个分桶包含一个文档集合，该文档集合符合某些过滤条件。
聚合查询类型 在 Elasticsearch 中，聚合查询可以分为以下几类：
指标聚合器 指标聚合器（Metric Aggregator）用来计算文档属性的统计信息，如最小值、最大值、平均值、总和、数量等等。指标聚合器包括：
Avg Aggregation：计算文档属性的平均值。 Cardinality Aggregation：计算文档属性的基数（即不同值的数量）。 Max Aggregation：计算文档属性的最大值。 Min Aggregation：计算文档属性的最小值。 Sum Aggregation：计算文档属性的总和。 Value Count Aggregation：计算文档属性的值数量。 桶聚合器 桶聚合器（Bucket Aggregator）用来将文档集合分成多个桶，每个桶都符合某些过滤条件。桶聚合器包括：
Date Histogram Aggregation：按时间段将文档分成多个桶。 Date Range Aggregation：按时间范围将文档分成多个桶。 Geo Distance Aggregation：按地理位置将文档分成多个桶。 Geo Hash Grid Aggregation：按地理位置的格子将文档分成多个桶。 Histogram Aggregation：按数字范围将文档分成多个桶。 Range Aggregation：按数字范围将文档分成多个桶。 Terms Aggregation：按文档属性将文档分成多个桶。 管道聚合器 管道聚合器（Pipeline Aggregator）用来将其他聚合器的结果作为输入，计算新的聚合结果。管道聚合器包括：
Average Bucket Aggregation：计算每个桶中文档属性的平均值。 Bucket Script Aggregation：使用自定义脚本计算桶的聚合结果。 Bucket Selector Aggregation：根据自定义条件过滤桶。 Derivative Aggregation：计算桶聚合器结果的一阶导数。 Max Bucket Aggregation：找到某个桶聚合器结果最大的桶。 Min Bucket Aggregation：找到某个桶聚合器结果最小的桶。 Sum Bucket Aggregation：计算某个桶聚合器结果的总和。</description></item><item><title/><link>/io-%E7%B3%BB%E5%88%97standard-io/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/io-%E7%B3%BB%E5%88%97standard-io/</guid><description>该系列主要对文件系统 io 进行分析总结，分为如下几章：
文件系统io基础 mmap 异步io: AIO, io_uring Vectored io mmap 是银弹吗？：论文解读 文件系统 io 是数据密集型系统的核心操作，对于数据库内核开发人员来说，理解 io 工作原理是特别重要的。本章主要介绍文件系统 io 基础知识，并介绍使用最频繁的 io 类型。
xxx 块设备（Block Device）是一种按照固定大小的块进行读写的设备，通常是以扇区（Sector）为单位，每个扇区大小为 512 字节或更多。块设备允许操作系统随机地读取或写入块中的数据，因为数据存储在固定大小的块中，而且块设备一般是能够缓存数据的，这使得块设备的访问速度比字符设备更快。
块设备通常包括机械硬盘、固态硬盘、光盘、USB存储设备等，它们通过操作系统的块设备驱动程序来与计算机进行通信。在操作系统中，文件系统一般使用块设备来存储和读取数据，因为块设备支持随机访问和缓存，使得文件系统可以快速地读取和写入数据。
扇区（Sector）/块（Block）/页（Page） 扇区是块设备传输的最小单元，大多数硬盘的扇区大小为 512 字节。块是由多个相邻扇区组合而成，是设备驱动程序操作的单位，典型的块大小为 512, 1024, 2048 和 4096 字节。</description></item><item><title>站点示例</title><link>/flinks.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/flinks.html</guid><description>如想交换本站友情链接，请在评论区留下你的站点信息，格式参考如下： - name: Hugo-NexT desc: Hugo NexT 官方预览网站。 avatar: https://hugo-next.eu.org/imgs/hugo_next_avatar.png link: https://hugo-next.eu.org</description></item></channel></rss>