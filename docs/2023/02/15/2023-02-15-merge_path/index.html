<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="description">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      Merge Path - A Visually Intuitive Approach to Parallel Merging 论文解读 | Debuger
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/css/plugins/gitment.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
  
    
<script src="/js/gitment.js"></script>

  
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


  
  
    
<script src="/js/local-search.js"></script>


<meta name="generator" content="Hexo 6.3.0"></head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>
  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>Debuger</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/project/" class="item-link">Projects</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
      
        <li class="menu-item menu-item-search right-list">
    <a role="button" class="popup-trigger">
        <i class="fa fa-search fa-fw"></i>
    </a>
</li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/project/" class="menu-link">Projects</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
    
      <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
            <span class="search-icon">
                <i class="fa fa-search"></i>
            </span>
            <div class="search-input-container">
                <input autocomplete="off" autocapitalize="off"
                    placeholder="Please enter your keyword(s) to search." spellcheck="false"
                    type="search" class="search-input">
            </div>
            <span class="popup-btn-close">
                <i class="fa fa-times-circle"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>
    
  </div>
</header>

    <div id="article-banner">
  <h2>Merge Path - A Visually Intuitive Approach to Parallel Merging 论文解读</h2>
  <p class="post-date">2023-02-15</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><blockquote>
<p>在看DuckDB技术博客时，了解到这篇论文。文章提出的算法非常实用，在工程实践中应用效果也很好。本文主要对论文核心部分进行解读，并会根据自己的理解加以叙述，若有不当之处，欢迎纠正。</p>
</blockquote>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>在工程实践中，合并两个有序数组是非常常见的操作。最直观的实现方式就是采用一次归并排序，直接将两个有序数组合并生成一个新的有序数组。这种方式简单直观，也最容易实现，在数据集比较小的时候，性能特别好，时延几乎不计。但是在数据集较大的情况下，对于数据库这种对时延较为苛刻的系统来说，时延则不得不成为一个关注点。</p>
<p>在现代CPU多核架构下，可以充分利用CPU并行计算能力，采用多线程并行合并可以成倍提升性能，降低时延。</p>
<p>给一个长度为 $n$ 的乱序数组，将其排序，考虑merge-sort算法，需要 $\log_2n$ 轮排序，第一轮排序需要将 $n&#x2F;2$ 个 $pairs$ 比较排序，第二轮需要将 $n&#x2F;4$ 个 $pairs$ 排序，最后一轮将 $2$ 个 $pairs$  排序生成单独的排序数组。</p>
<p>考虑使用并行merge-sort算法，使用 $p$ 核计算机，假设 $n&gt;&gt;p$，在前面的轮次，每个核可以负责一批 $pairs$ 的排序工作，越往后需要排序的 $pairs$ 更少，那么并不是每个核都能分得 $pairs$，不能充分发挥并行化计算能力。为了有效地发挥并行计算能力，需要对有序数组的合并也并行化，这样每个核在任何时候都能参与计算。</p>
<p>论文认为一个高效的并行合并算法必须具备如下特征：</p>
<ul>
<li>所有核拥有相同的工作量（负载均衡）</li>
<li>尽可能少的核间通信</li>
<li>最小化额外工作（为了并行化所做的额外工作）</li>
<li>高效内存访问（高缓存命中率和最小的缓存一致性开销）</li>
</ul>
<p>一种简单的方法是将两个有序数组按照核数平均切割成多个子数组，然后每个核分配一对长度相同的子数组，各个核排序生成一个有序数组，再将所有有序数组串联起来便得到最终的排序数组。如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr1 = [1,3,5,7,9,11,13,15,17]   split to --&gt; [1,3,5]        [7,9,11]        [13,15,17]</span><br><span class="line">arr2 = [2,4,6,8,10,12,14,16,18]  split to --&gt; [2,4,6]        [8,10,12]       [14,16,18]</span><br><span class="line">                                            core0|          core1|           core2|</span><br><span class="line">                                           [1,2,3,4,5,6,  7,8,9,10,11,12,  13,14,15,16,17,18]</span><br></pre></td></tr></table></figure>

<p>如上，假设有3核，两个数组都等分成3个子数组，然后每个核合并一对子数组，最终得到一个合并完成的有序数组。一切看起来都没有问题。但是假设两个数组如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr1 = [20,21,22,23,24,25,26,27,28]  split to --&gt; [20,21,22]          [23,24,25]        [26,27,28]</span><br><span class="line">arr2 = [10,11,12,13,14,15,16,17,18]  split to --&gt; [10,11,12]          [13,14,15]        [16,17,18]</span><br><span class="line">                                                  core0|              core1|            core2|</span><br><span class="line">                                              [10,11,12,20,21,22,  13,14,15,23,24,25  16,17,18,26,27,28]</span><br></pre></td></tr></table></figure>

<p>很不幸，上面的排序结果不对，因此，正确的数组划分成为了关键点。</p>
<p>论文提出了一种用于并行随机存取机 (Parallel Random Access Machines, PRAM) 的并行合并算法，即允许并发（并行）访问内存的共享内存架构。论文的算法具备负载均衡、无锁、高效内存访问的特点，仅需少量额外工作。为了实现高效的并行算法，论文提出了一种叫做 Merge Path 的方法，这也是论文的核心，下文将详细分析 Merge Path 的原理。</p>
<h3 id="Merge-Path"><a href="#Merge-Path" class="headerlink" title="Merge Path"></a>Merge Path</h3><p>假设两个有序数组 $A$ 和 $B$，长度分别为 $|A|$ 和 $|B|$， $A$ 和 $B$ 构成矩阵 $M$，如下图所示：</p>
<img src="/images/database/merge-path-1.png" alt="image-20230211205857408" style="zoom:50%;" />

<blockquote>
<p>声明：本文所有图片都来源于原论文。</p>
</blockquote>
<p>我们来看下 Merge path 是如何构造的。要合并两个有序数组，我们从起点(1, 1)开始，比较 $A[1]$ 和 $B[1]$，如果 $A[1]&gt;B[1]$，将位置往右移动，否则往下移动，重复上述步骤直到走到右下方终点。最终得到一条路径（图中黄色路径），这条路径就称为 Merge Path。</p>
<p>通过构造 Merge Path 可以得出下面几个结论：</p>
<p><strong>引理1</strong>：从头到尾遍历 Merge Path 的过程中，向右则选取 $|B|$ 中未使用的最小值，向下则选取 $|A|$ 中未使用的最小值，最终得到的结果即为合并后的有序数组。</p>
<p><strong>引理2</strong>：合并路径上，任何<strong>连续片段</strong>都由 $A$ 的连续元素序列和 $B$ 的连续元素序列组成。</p>
<p><strong>引理3</strong>：合并路径的<strong>非重叠</strong>片段由不相交的元素集组成，反之亦然。</p>
<p><strong>引理4</strong>：对于合并路径上两个<strong>不相交</strong>的片段，后面片段的元素集肯定大于或等于前面片段的元素集。</p>
<p><strong>定理5</strong>：考虑一组子数组对（来源于$A$ 和 $B$），这些子数组对包含了所有元素，它们一旦排序便形成了合并路径的连续片段。可以断言，这些子数组对可以并行合并，合并后的结果拼接在一起便形成了最终的有序数组。</p>
<p><strong>推论6</strong>：将合并路径划分为任何个<strong>不重叠</strong>的片段，这些片段对应的子数组对都可以独立合并，合并后的结果按片段顺序串联形成一个合并路径上有序数组。</p>
<p><strong>推论7</strong>：将合并路径<strong>平均划分</strong>为相同大小的片段，并行地合并片段对应的数组对，可以在多个处理器间达到<strong>负载均衡</strong>的效果。</p>
<h3 id="并行合并和排序"><a href="#并行合并和排序" class="headerlink" title="并行合并和排序"></a>并行合并和排序</h3><p>有了上面的结论，我们来看下如何实现高效的并行合并算法。根据推论6和7，可以知道，需要将合并路径按照cpu核数平均划分，得到大小均匀的片段，然后并行地合并这些片段对应的数组对即可。要均匀地划分合并路径，其实就是要找到这些划分点，因此，算法的核心就是找这些划分点。算法核心思想如下：</p>
<ul>
<li>根据核数计算出每个线程处理的数据量</li>
<li>对于每个线程，计算其所处理的起点偏移</li>
<li>对于每个线程，根据起点偏移计算其在合并路径上对应的坐标点$(x, y)$</li>
<li>对于每个线程，根据自身的起点坐标点和终点坐标点(下一个线程的起点)合并数组对</li>
<li>对于每个线程，将合并的结果写入最终数组对应的下标即可（根据前面的引理可知不同线程片段对应的元素集不会重复，因此这里不会出现内存并发安全问题）</li>
</ul>
<p>通过上面的算法便能找到所有划分点，如下图：</p>
<img src="/images/database/merge-path-2.png" alt="image-20230211230438935" style="zoom:50%;" />

<p>划分点将合并路径平均分割，然后由每个线程独立地合并排序每个片段对应的数组对，得到最终的合并数组。论文提供了算法的实现代码，见<a target="_blank" rel="noopener" href="https://github.com/ogreen/MergePathOMP">github地址</a>。笔者测了下，有点小bug（在某些情况下可能会coredump，笔者用Golang重新实现了算法，见<a target="_blank" rel="noopener" href="https://github.com/zhenyuxie/MergePath">github地址</a>）。</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>测试环境：MacBook Air M1 芯片，逻辑核数 8</p>
<p>测试数据量：$A$ 和 $B$ 的size均为1亿，合并成2亿的数组</p>
<p>直接用论文提供的代码测试，测试结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">$ make test100m</span><br><span class="line">./a.out -A 100000000 -B 100000000 -t 2</span><br><span class="line">OpenMP MergePath Implementation</span><br><span class="line"></span><br><span class="line">Merging: A[100000000] B[100000000] to C[200000000] using 2 threads</span><br><span class="line"></span><br><span class="line">serial merge 0.745051</span><br><span class="line">Total OpenMP MergePath 0.379064</span><br><span class="line">Speedup over serial merge 1.965501</span><br><span class="line">MERGE SUCCESSFUL</span><br><span class="line"></span><br><span class="line">Total Time 0.437201</span><br><span class="line">./a.out -A 100000000 -B 100000000 -t 4</span><br><span class="line">OpenMP MergePath Implementation</span><br><span class="line"></span><br><span class="line">Merging: A[100000000] B[100000000] to C[200000000] using 4 threads</span><br><span class="line"></span><br><span class="line">serial merge 0.745274</span><br><span class="line">Total OpenMP MergePath 0.195741</span><br><span class="line">Speedup over serial merge 3.807443</span><br><span class="line">MERGE SUCCESSFUL</span><br><span class="line"></span><br><span class="line">Total Time 0.231412</span><br><span class="line">./a.out -A 100000000 -B 100000000 -t 8</span><br><span class="line">OpenMP MergePath Implementation</span><br><span class="line"></span><br><span class="line">Merging: A[100000000] B[100000000] to C[200000000] using 8 threads</span><br><span class="line"></span><br><span class="line">serial merge 0.750698</span><br><span class="line">Total OpenMP MergePath 0.132132</span><br><span class="line">Speedup over serial merge 5.681429</span><br><span class="line">MERGE SUCCESSFUL</span><br><span class="line"></span><br><span class="line">Total Time 0.160297</span><br><span class="line">./a.out -A 100000000 -B 100000000 -t 16</span><br><span class="line">OpenMP MergePath Implementation</span><br><span class="line"></span><br><span class="line">Merging: A[100000000] B[100000000] to C[200000000] using 16 threads</span><br><span class="line"></span><br><span class="line">serial merge 0.750842</span><br><span class="line">Total OpenMP MergePath 0.126917</span><br><span class="line">Speedup over serial merge 5.916009</span><br><span class="line">MERGE SUCCESSFUL</span><br><span class="line"></span><br><span class="line">Total Time 0.164079</span><br></pre></td></tr></table></figure>

<p>线程数从2到16递增，线程数越多，并发数越大，MergePath 算法也就越快。当然线程数并不是越多越好，最佳线程数和CPU配置有关系。从上面的结果可以看出，当线程数为16时，并行Merge比普通Merge快了将近6倍，说明并行Merge的实践表现效果非常优秀。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本文主要解读了论文核心部分，还有些遗留内容并未解读，如果想了解更详细内容，可以直接看原论文。同时，笔者用Golang实现了论文中的算法（更加易懂），源码已上传github，感兴趣的同学可以阅读参考。</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li><a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1406.2628.pdf">https://arxiv.org/pdf/1406.2628.pdf</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/ogreen/MergePathOMP">https://github.com/ogreen/MergePathOMP</a></li>
</ul>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#mergesort" >
    <span class="tag-code">mergesort</span>
  </a>

  <a href="/tags#database" >
    <span class="tag-code">database</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2022/12/18/2022-12-18-lucene-DirectMonotonicWriter/">
        <span class="nav-arrow">← </span>
        
          lucene 编码技术 - DirectMonotonicWriter
        
      </a>
    
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
    <!-- 二维码 END -->
    
      <!-- Gitment START -->
      <div id="comments"></div>
      <!-- Gitment END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-nav-text">介绍</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Merge-Path"><span class="toc-nav-text">Merge Path</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%B9%B6%E8%A1%8C%E5%90%88%E5%B9%B6%E5%92%8C%E6%8E%92%E5%BA%8F"><span class="toc-nav-text">并行合并和排序</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-nav-text">测试</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-nav-text">小结</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Reference"><span class="toc-nav-text">Reference</span></a></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'https://zhenyuxie.github.io/2023/02/15/2023-02-15-merge_path/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', '/css/images/error_icon.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== '/css/images/error_icon.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>




  <script>
    var gitmentConfig = "zhenyuyxie";
    if (gitmentConfig !== 'undefined') {
      var gitment = new Gitment({
        id: "Merge Path - A Visually Intuitive Approach to Parallel Merging 论文解读",
        owner: "zhenyuyxie",
        repo: "zhenyuxie.github.io",
        oauth: {
          client_id: "1f2036d171d35790250b",
          client_secret: "d1f9e1ae4ea60f6783f5dace256aec77eed5d99b"
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  </script>




    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2023 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      hljs.configure({useBR: true});
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/js/script.js"></script>


  </body>
</html>